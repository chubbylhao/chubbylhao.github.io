<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HOG特征</title>
    <url>/2022/04/16/hog-te-zheng/</url>
    <content><![CDATA[<p>梯度方向直方图 <code>（Histogram of Oriented Gradient，HOG）</code>
特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子。它通过计算和统计图像局部区域的梯度方向直方图来构成特征。
<code>HOG</code> 特征结合 <code>SVM</code>
分类器已经被广泛应用于图像识别中，尤其在行人检测中获得了极大的成功</p>
<hr />
<h4 id="算法思想">算法思想</h4>
<p><code>HOG</code> 特征的核心思想是在一幅图像中，局部目标的表象和形状
<code>（appearance and shape）</code>
能够被梯度和边缘的方向密度（梯度的统计信息，而梯度主要存在于边缘地方）很好地描述。通过将整幅图像分为多个小的连通区域
<code>（cell）</code> ，并计算每个 <code>cell</code>
的梯度或边缘方向直方图，这些直方图的组合可用于构成特征描述子，为了提高准确率，可以将局部直方图在图像更大范围内
<code>（称为block</code>） 进行对比度归一化
<code>（constrast-normalized）</code>
。所采用的方法是：先计算各直方图在对应的 <code>block</code>
中的密度，然后根据这个密度对 <code>block</code> 中的所有
<code>cell</code> 做归一化 <code>（normalize）</code>
。归一化操作对光照变化和阴影具有更好的鲁棒性</p>
<hr />
<h4 id="算法特点">算法特点</h4>
<ul>
<li><code>HOG</code>
特征是在图像的局部区域内进行操作，对图像几何和光学的变化有较好的稳健性，这两种变化只会出现在更大的空域上</li>
<li>在粗粒度的空域抽样、细粒度的方向抽样，以及较强的局部光学归一化条件下，只要行人大体保持直立的姿势，可以容许行人有一些细微的肢体动作，而不影响检测效果</li>
</ul>
<hr />
<h4 id="算法实现">算法实现</h4>
<p><code>HOG</code> 特征提取的流程如下：</p>
<h5 id="图像预处理">图像预处理</h5>
<ul>
<li>灰度化： <code>HOG</code>
提取的是纹理特征，<strong>颜色信息不起作用</strong>，所以将彩色图转化为灰度图</li>
<li><code>Gamma</code> 校正（归一化）：对图像进行 <code>Gamma</code>
校正，完成对整个图像的标准化（归一化），可以调节图像的对比度，降低局部光照不均匀或者阴影的影响，同时也可以在一定程度上降低噪声的干扰，提高特征描述器对光照等干扰因素的鲁棒性。校正公式如下：</li>
</ul>
<p><span class="math display">\[
I(x, y) = I(x, y)^{\gamma}, \gamma = \dfrac{1}{2}
\]</span></p>
<h5 id="计算图像梯度">计算图像梯度</h5>
<p>分别求取图像水平方向和垂直方向的梯度，然后计算每个像素点的梯度幅值和方向，微分求图像梯度不仅可以捕获图像边缘和纹理信息，而且可以弱化光照不均匀的影响
<span class="math display">\[
G\_x(x,y) = I(x+1,y) - I(x-1,y) \\
G\_y(x,y) = I(x,y+1) - I(x,y-1) \\
\nabla G(x,y) = \sqrt{G\_x(x,y)^2+G\_y(x,y)^2} \\
\theta(x,y) = arctan(G\_y(x,y) / G\_x(x,y))
\]</span> 一般采用梯度算子对图像进行卷积运算求取图像梯度，例如用 $
[-1,0,1] $ 梯度算子对图像进行卷积操作得到水平方向的梯度分量，用 $
[-1,0,1]^T $
梯度算子进行卷积操作得到竖直方向的梯度分量，然后求取图像的梯度幅值和方向</p>
<h5 id="在-cell-中计算梯度方向直方图">在 <code>cell</code>
中计算梯度方向直方图</h5>
<p>将图像划分为若干个连通区域 <code>（cell）</code>，例如每个
<code>cell</code> 为 $ 8 * 8 $ 个像素，相邻的 <code>cell</code>
之间不重叠，将所有梯度方向划分为 <code>9</code> 个方向块
<code>（bin）</code> ，然后在每个 <code>cell</code>
内统计梯度方向直方图。在计算梯度方向时，可把方向的角度范围定位 $ (0,
180^{}) $ 或者 $ (0, 360^{}) $ 。最后每个 <code>cell</code> 都对应一个
<code>9</code> 维的特征向量。此外，还可以考虑梯度幅值作为
<code>bin</code>
的统计权重。在行人检测中，通过给局部图像区域进行编码，可以保持对目标对象的姿势和外观的弱敏感性，更好地捕获图像的轮廓和纹理信息</p>
<h5 id="在-block-中归一化梯度方向直方图">在 <code>block</code>
中归一化梯度方向直方图</h5>
<p>将多个 <code>cell</code> 组合成更大连通块 <code>（block）</code> ，将
<code>block</code> 内所有 <code>cell</code>
的特征向量<strong>串联</strong>起来便得到该 <code>block</code> 的
<code>HOG</code> 特征描述子，不同 <code>block</code>
之间可能相互重叠，可以有效地利用局部邻域信息。类比在卷积神经网络中，掩码和步长的选择。在更大范围内
<code>（block）</code>
统计梯度直方图，并做归一化处理，能够更好地适应光照和对比度的变化。常用的归一化方法有以下几种：</p>
<ul>
<li><code>L2-norm</code></li>
</ul>
<p><span class="math display">\[
v = \dfrac{v}{\sqrt{\left|v\right\|\_{2}^{2} + \varepsilon^2}}
\]</span></p>
<ul>
<li><code>L1-norm</code></li>
</ul>
<p><span class="math display">\[
v = \dfrac{v}{\left|v\right\|\_{1} + \varepsilon}
\]</span></p>
<ul>
<li><code>L1-sqrt</code></li>
</ul>
<p><span class="math display">\[
v = \sqrt{\dfrac{v}{\left|v\right\|\_{1} + \varepsilon}}
\]</span></p>
<ul>
<li>还有一种 <code>L2-Hys</code> ，即先做一次 <code>L2-norm</code>
，然后把大于特定值 <code>0.2</code> 的分量幅值为 <code>0.2</code>
再做一次 <code>L2-norm</code> ，一般在检测中采用 <code>L2-norm</code>
的效果更好。在一个 <code>block</code> 中，如果 <code>cell</code>
的数量为 $ 2 * 2 $ ，那 <code>block</code> 的特征数为 $ 2 * 2 * 9 = 36 $
维特征</li>
</ul>
<h5 id="统计整幅图像检测窗口的-hog-特征">统计整幅图像(检测窗口)的
<code>HOG</code> 特征</h5>
<p>在实际应用中，通常是选取固定大小的滑动窗口来提取 <code>HOG</code>
特征，对于一个 $ 64 * 128 $ 的图像窗口，每 $ 8 * 8 $ 个像素组成一个
<code>cell</code> ，每 $ 2 * 2 $ 个 <code>cell</code> 组成一个
<code>block</code> ，一共有 $ (8-1) * (16-1) = 105 $ 个
<code>block</code> ，因此该图像的窗口特征维数为 $ 105 * 36 = 3780 $
。当然也可以将整幅图像作为一个窗口来提取 <code>HOG</code> 特征</p>
<hr />
<h4 id="代码实现">代码实现</h4>
<p>根据以上步骤流程，提取 <code>HOG</code> 特征的 <code>MATLAB</code>
代码如下：（其中 <code>N</code> 就是我们最终想得的 <code>HOG</code>
描述子）</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all; clear; clc;</span><br><span class="line">img = imread(<span class="string">&#x27;person.png&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(img,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    img = rgb2gray(img);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">img = rescale(<span class="built_in">sqrt</span>(im2double(img)));    <span class="comment">% gamma为1/2的光照（阴影）校正</span></span><br><span class="line">img = imresize(img,<span class="number">0.5</span>);</span><br><span class="line"><span class="comment">% figure; imshow(img,[]);</span></span><br><span class="line">Gx = imfilter(img,[<span class="number">-0.5</span>;<span class="number">0</span>;<span class="number">0.5</span>],<span class="string">&#x27;symmetric&#x27;</span>);</span><br><span class="line">Gy = imfilter(img,[<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>],<span class="string">&#x27;symmetric&#x27;</span>);</span><br><span class="line">Gmag = <span class="built_in">sqrt</span>(Gx.^<span class="number">2</span> + Gy.^<span class="number">2</span>);</span><br><span class="line"><span class="comment">% figure; imshow(rescale(Gmag),[]);</span></span><br><span class="line">Gdir = atan2d(Gy,Gx);    <span class="comment">% 使用atand将有：0/0出现NaN，(非0)/0出现±Inf，使用atan2d则无此顾虑</span></span><br><span class="line">[rows,cols] = <span class="built_in">size</span>(img);</span><br><span class="line">cell_size = <span class="number">8</span>;</span><br><span class="line">row_cells = <span class="built_in">floor</span>(rows/cell_size);</span><br><span class="line">col_cells = <span class="built_in">floor</span>(cols/cell_size);</span><br><span class="line">M = cell(row_cells,col_cells);    <span class="comment">% 通过划分cell获得的描述子</span></span><br><span class="line">bins = <span class="number">9</span>;</span><br><span class="line">bin_step = <span class="number">180</span>/bins;</span><br><span class="line">cell_hist = <span class="built_in">zeros</span>(<span class="number">1</span>,bins);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:row_cells</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:col_cells</span><br><span class="line">        op_cell_mag = Gmag((<span class="built_in">i</span><span class="number">-1</span>)*cell_size+<span class="number">1</span>:<span class="built_in">i</span>*cell_size,(<span class="built_in">j</span><span class="number">-1</span>)*cell_size+<span class="number">1</span>:<span class="built_in">j</span>*cell_size);</span><br><span class="line">        op_cell_dir = Gdir((<span class="built_in">i</span><span class="number">-1</span>)*cell_size+<span class="number">1</span>:<span class="built_in">i</span>*cell_size,(<span class="built_in">j</span><span class="number">-1</span>)*cell_size+<span class="number">1</span>:<span class="built_in">j</span>*cell_size);</span><br><span class="line">        label = <span class="built_in">ceil</span>(((op_cell_dir&lt;<span class="number">0</span>)*<span class="number">180</span>+op_cell_dir)/bin_step);</span><br><span class="line">        label(label==<span class="number">0</span>) = <span class="number">1</span>;    <span class="comment">% 0°属于第一个bin</span></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">numel</span>(label)</span><br><span class="line">            cell_hist(uint8(label(k))) = cell_hist(uint8(label(k))) + op_cell_mag(k);    <span class="comment">% 按权重投票</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        M&#123;<span class="built_in">i</span>,<span class="built_in">j</span>&#125; = cell_hist;</span><br><span class="line">        cell_hist = <span class="built_in">zeros</span>(<span class="number">1</span>,bins);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 可视化通过划分cell获得的描述子（为了理解而加的代码）</span></span><br><span class="line"><span class="comment">% hog = zeros(rows,cols);</span></span><br><span class="line"><span class="comment">% figure; imshow(hog,[]); hold on;</span></span><br><span class="line"><span class="comment">% for i = 1:row_cells</span></span><br><span class="line"><span class="comment">%     for j = 1:col_cells</span></span><br><span class="line"><span class="comment">%         centre = [(i-0.5)*cell_size ,(j-0.5)*cell_size];    % 绘制中心</span></span><br><span class="line"><span class="comment">%         for k = 1:bins</span></span><br><span class="line"><span class="comment">%             offset = [M&#123;i,j&#125;(k)*cosd((k-0.5)*bin_step),M&#123;i,j&#125;(k)*sind((k-0.5)*bin_step)];</span></span><br><span class="line"><span class="comment">%             quiver(centre(2),centre(1),offset(1),offset(2),2,&#x27;w&#x27;);    % 绘制单向箭头</span></span><br><span class="line"><span class="comment">%         end</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% hold off;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 在block中归一化梯度方向直方图（N即为最终所求的描述子）</span></span><br><span class="line">block_size = <span class="number">2</span>;</span><br><span class="line">N = cell(row_cells<span class="number">-1</span>,col_cells<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:row_cells<span class="number">-1</span>    <span class="comment">% blok的数量显然要更少</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:col_cells<span class="number">-1</span></span><br><span class="line">        block_hist = [M&#123;<span class="built_in">i</span>,<span class="built_in">j</span>&#125;,M&#123;<span class="built_in">i</span>,<span class="built_in">j</span>+<span class="number">1</span>&#125;,M&#123;<span class="built_in">i</span>+<span class="number">1</span>,<span class="built_in">j</span>&#125;,M&#123;<span class="built_in">i</span>+<span class="number">1</span>,<span class="built_in">j</span>+<span class="number">1</span>&#125;];</span><br><span class="line">        N&#123;<span class="built_in">i</span>,<span class="built_in">j</span>&#125; = block_hist/sum(block_hist);    <span class="comment">% 归一化</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>提取效果：（可以很清晰地看到， <code>HOG</code>
描述的是<strong>纹理信息</strong>）</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/HOG/person.png" style="zoom:70%;" /><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/HOG/hog_person.png" style="zoom: 64.6%;" /></p>
<hr />
<h4 id="参考文章网上文章一搜一堆">参考文章（网上文章一搜一堆）</h4>
<p><a
href="https://senitco.github.io/2017/06/10/image-feature-hog/">本博客理论部分的主要来源</a></p>
<p><a href="https://shartoo.github.io/2019/03/04/HOG-feature/">HOG
特征详解（这篇不错）</a></p>
<p><a
href="https://blog.csdn.net/liulina603/article/details/8291093">目标检测的图像特征提取之
HOG 特征</a></p>
<p><a
href="https://blog.csdn.net/qinghuaci666/article/details/81868567">这是一篇博采众长的文章（推荐）</a></p>
<p><a
href="https://www.cnblogs.com/alexme/p/11361563.html">只能说这个是十分的详细（不过我没有细看）</a></p>
<p><a href="https://www.cnblogs.com/Jack-Elvis/p/11285290.html">HOG
特征</a></p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Haar特征</title>
    <url>/2022/04/18/haar-te-zheng/</url>
    <content><![CDATA[<p>网上有关 <code>Haar</code>
特征的文章很多，并且写得都很好，本人借此机会偷个懒，附上链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/38056144">人脸 Haar
特征快速检测及其特征计算（推荐阅读）</a></p>
<p><a
href="https://blog.csdn.net/xizero00/article/details/46929261">特征提取之
Haar 特征</a></p>
<p><a
href="https://blog.csdn.net/zouxy09/article/details/7929570">目标检测的图像特征提取之
Haar 特征</a></p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>LBP特征</title>
    <url>/2022/04/17/lbp-te-zheng/</url>
    <content><![CDATA[<p>网上有关 <code>LBP</code>
特征的文章很多，并且写得都很好，本人借此机会偷个懒，附上链接：</p>
<p><a
href="https://blog.csdn.net/quincuntial/article/details/50541815">LBP
特征原理及代码实现（首推，写得超棒）</a></p>
<p><a
href="https://senitco.github.io/2017/06/12/image-feature-lbp/">图像特征提取之
LBP 特征</a></p>
<p><a
href="https://clarkhedi.github.io/2020/09/28/ju-bu-er-zhi-mo-shi-lbp/">局部二值模式（LBP）</a></p>
<p>下面为图像插值的相关文章：（圆形 <code>LBP</code> 要用到）</p>
<p><a
href="https://blog.csdn.net/huang1024rui/article/details/46545329">双线性插值（MATLAB实现）</a></p>
<p><a href="https://anymechen.github.io/ejq1xAVT-/">图像插值算法及
MATLAB 实现</a></p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Harris矩阵和Hessian矩阵</title>
    <url>/2022/04/15/harris-ju-zhen-he-hessian-ju-zhen/</url>
    <content><![CDATA[<h4 id="harris-矩阵使用的是一阶导数"><code>Harris</code>
矩阵（使用的是一阶导数）</h4>
<p>令 $ f(x,y) $ 表示图像，并令 $ f(x_{0},y_{0}) $ 表示以点 $
(x_{0},y_{0}) $ 为中心的一小块邻域图像（假设邻域图像的大小为 $ n $ × $ n
$
），将其移动一定量得到另一小块图像，则该两块图像的灰度差异（灰度变化）可以用如下表达式来衡量：
<span class="math display">\[
C(\Delta x,\Delta y) = \sum_{n\times n}w(x_{0},y_{0})[f(x_{0}+\Delta
x,y_{0}+\Delta y)
- f(x_{0},y_{0})]^2
\]</span> 其中， $ w(x_{0},y_{0}) $ 是以点 $ (x_{0},y_{0}) $
为中心的<strong>盒式加权函数</strong>或<strong>高斯加权函数</strong></p>
<p>将图像 $ f(x,y) $ 在 $ x=x_{0},y=y_{0} $ 处进行泰勒展开，可得： <span
class="math display">\[
f(x_{0} + \Delta x,y_{0} + \Delta y) = f(x_{0},y_{0})
+ \begin{pmatrix} f_{x}(x_{0},y_{0}) \\ f_{y}(x_{0},y_{0})\end{pmatrix}
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix} \\
+ \frac{1}{2!}\begin{pmatrix} \Delta x &amp; \Delta y\end{pmatrix}
\begin{pmatrix} f_{xx}(x_{0},y_{0}) &amp; f_{xy}(x_{0},y_{0} \\
f_{yx}(x_{0},y_{0}) &amp; f_{yy}(x_{0},y_{0})\end{pmatrix}
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}
+o\lVert\Delta x^{2} + \Delta y^{2}\rVert
\]</span> 若只取线性展开项，则灰度差异（灰度变化）表达式变为： <span
class="math display">\[
C(\Delta x,\Delta y) = \sum_{n\times n}w(x_{0},y_{0})[\Delta xf_{x}
(x_{0},y_{0}) + \Delta yf_{y}(x_{0},y_{0})]^2
\]</span>
显然，平方项是一个<strong>实二次型</strong>，可使用矩阵表示法： <span
class="math display">\[
[\Delta xf_{x}(x_{0},y_{0}) + \Delta yf_{y}(x_{0},y_{0})]^2 =
\begin{pmatrix} \Delta x &amp; \Delta y\end{pmatrix}
\begin{pmatrix} f^2_{x}(x_{0},y_{0}) &amp; f_{x}f_{y}(x_{0},y_{0})
\\ f_{x}f_{y}(x_{0},y_{0}) &amp; f^2_{y}(x_{0},y_{0})\end{pmatrix}
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}
\]</span> 因加权求和运算是线性运算，故交换运算次序，得： <span
class="math display">\[
C(\Delta x,\Delta y) =
\begin{pmatrix} \Delta x &amp; \Delta y\end{pmatrix}
\sum_{n\times n}w(x_{0},y_{0})
\begin{pmatrix} f^2_{x}(x_{0},y_{0}) &amp; f_{x}f_{y}(x_{0},y_{0})
\\ f_{x}f_{y}(x_{0},y_{0}) &amp; f^2_{y}(x_{0},y_{0})\end{pmatrix}
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}
\]</span> 若令： <span class="math display">\[
H = \sum_{n\times n}w(x_{0},y_{0})
\begin{pmatrix} f^2_{x}(x_{0},y_{0}) &amp; f_{x}f_{y}(x_{0},y_{0})
\\ f_{x}f_{y}(x_{0},y_{0}) &amp; f^2_{y}(x_{0},y_{0})\end{pmatrix}
\]</span>
则灰度差异（灰度变化）表达式变为：（这是一个<strong>实二次型</strong>）
<span class="math display">\[
C(\Delta x,\Delta y) =
\begin{pmatrix} \Delta x &amp; \Delta y\end{pmatrix}
H
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}
\]</span></p>
<blockquote>
<p>因为 <code>H</code>
矩阵的主对角元（即两个平方项的系数）均大于零，因此上述<strong>实二次型</strong>在空间中是一个<strong>椭圆抛物面</strong></p>
</blockquote>
<p>为研究其变化率，此处便出现了两种思路：</p>
<ul>
<li>研究其二阶导数（因为上述<strong>实二次型</strong>由一阶导数构成，一阶导数再求导数就是二阶导数），而其二阶导数就是
<code>Hessian</code> 矩阵</li>
<li>研究椭圆抛物面的水平切面（椭圆抛物面的切面都是椭圆，其中<strong>短轴方向是变化最快的方向</strong>，<strong>长轴方向是变化最慢的方向</strong>）</li>
</ul>
<blockquote>
<p>此处研究水平切面法，则不妨令上述<strong>实二次型</strong>的值为
<code>1</code> ，有：</p>
</blockquote>
<p><span class="math display">\[
\begin{pmatrix} \Delta x &amp; \Delta y\end{pmatrix}
H
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}
= 1
\]</span></p>
<p>根据我前面写的文章：<a
href="http://localhost:4000/2022/04/13/dip-zhong-de-hessian-ju-zhen/">DIP
中的 Hessian 矩阵</a></p>
<p>可知矩阵 <code>H</code> 与上述椭圆存在关系：</p>
<blockquote>
<p>矩阵的两个特征向量的方向分别对应着椭圆的长短轴的方向</p>
<p>矩阵的两个特征值分别对应着椭圆的半短轴、半长轴的平方的倒数</p>
<p><strong>大特征值</strong>及其特征向量对应着椭圆的<strong>短轴</strong>，<strong>小特征值</strong>及其特征向量对应着椭圆的<strong>长轴</strong></p>
</blockquote>
<p><span class="math display">\[
\lambda_{min} = \frac{1}{a^2},\;\;\lambda_{max} =
\frac{1}{b^2}\;\;(a是半长轴，b是半短轴，即a\geq b)
\]</span></p>
<p>因此，我们说：大特征值对应的特征向量的方向代表着变化最慢的方向（灰度变化最小的方向），小特征值对应的特征向量的方向代表着变化最快的方向（灰度变化最大的方向）</p>
<p>在图像中，存在“平坦区域”、“边缘”和“角”三种基本的特征（以下的长短轴代表的是
<code>a</code> 和 <code>b</code> ，不是特征值）</p>
<ul>
<li>在“平坦区域”移动小块邻域图像，沿任何方向灰度变化都很小，即对应着两个小特征值（长轴），椭圆像一个<strong>很大的圆</strong></li>
<li>在“边缘”移动小块邻域图像，沿着“边缘”移动的灰度变化很小，垂直“边缘”移动的灰度变化很大，即沿“边缘”对应着小特征值（长轴），而垂直“边缘”对应着大特征值（短轴），椭圆像一个<strong>很扁平很狭长的椭圆</strong></li>
<li>在“角”移动小块邻域图像，沿任何方向灰度变化都很大，即对应着两个大特征值（短轴），椭圆像一个<strong>很小的圆</strong></li>
</ul>
<p>见下图：（<strong>注意，图中的长短轴表示的是特征值，不是
<code>a</code> 和 <code>b</code>
（跟上面的描述恰好相反，注意区别）！（特征值大，变化大，特征值小，变化小）</strong>）</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFeature/Hessian/Harris2.png" style="zoom:67%;" /></p>
<p>因此，我们可以总结：</p>
<ul>
<li>大特征值及其特征向量分别对应着椭圆的半短轴的平方的倒数和短轴的方向</li>
<li>小特征值及其特征向量分别对应着椭圆的半长轴的平方的倒数和长轴的方向</li>
<li>短轴方向变化快，大特征值方向变化快</li>
<li>长轴方向变化慢，小特征值方向变化慢</li>
</ul>
<hr />
<h4 id="hessian-矩阵使用的是二阶导数"><code>Hessian</code>
矩阵（使用的是二阶导数）</h4>
<p>上面提到过两种思路，一种是<strong>水平切面法</strong>（使用
<code>Harris</code>
矩阵分析），另一种是<strong>一阶导数再求导的变化率法</strong>（使用
<code>Hessian</code> 矩阵分析）</p>
<p><code>Hesssian</code>
矩阵反映的是图像中局部曲率的变化，是梯度的变化率。在二元函数的泰勒展开中，<code>Hesssian</code>
矩阵天然地对应着椭圆，其特征值、特征向量与椭圆长短轴、长短轴方向之间的对应关系与上述
<code>Harris</code> 矩阵的分析是完全一致的</p>
<hr />
<h4 id="解释一些问题">解释一些问题</h4>
<ul>
<li>为什么 <code>Harris</code> 矩阵使用的是一阶导数，
<code>Hessian</code>
矩阵使用的是二阶导数，二者均能使用实二次型（对应椭圆）的分析方法呢？</li>
</ul>
<blockquote>
<p>因为 <code>Harris</code> 矩阵的构造很巧妙，它定义了一个灰度变化值
<code>C</code> ，该值的计算表达式可化为实二次型的形式</p>
<p>而 <code>Hessian</code>
矩阵完全基于泰勒展开，并没有人为地定义一个类似于 <code>C</code>
的度量，它直接反应梯度的变化率</p>
<p>二者有相似之处，但绝不是一个东西，应当加以区分</p>
<p>即 <code>Harris</code> 特征点检测与 <code>Hessian</code>
特征点检测是完全不同的两种方法</p>
</blockquote>
<hr />
<h4 id="附上-harris-特征点检测的代码">附上 <code>Harris</code>
特征点检测的代码</h4>
<p><code>myHarris</code> 函数：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,y]</span> = <span class="title">myHarris</span><span class="params">(img,n)</span></span></span><br><span class="line">fx = imfilter(img,[<span class="number">-0.5</span>;<span class="number">0</span>;<span class="number">0.5</span>],<span class="string">&#x27;symmetric&#x27;</span>);</span><br><span class="line">fy = imfilter(img,[<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>],<span class="string">&#x27;symmetric&#x27;</span>);</span><br><span class="line">h = fspecial(<span class="string">&#x27;gaussian&#x27;</span>,<span class="number">7</span>,<span class="number">1</span>);</span><br><span class="line">fx2 = imfilter(fx.^<span class="number">2</span>,h);</span><br><span class="line">fy2 = imfilter(fy.^<span class="number">2</span>,h);</span><br><span class="line">fxy = imfilter(fx.*fy,h);</span><br><span class="line">[rows,cols] = <span class="built_in">size</span>(img);</span><br><span class="line">H = cell(rows,cols);</span><br><span class="line">R = <span class="built_in">zeros</span>(rows,cols);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(img)</span><br><span class="line">   H&#123;<span class="built_in">i</span>&#125; = [fx2(<span class="built_in">i</span>),fxy(<span class="built_in">i</span>);fxy(<span class="built_in">i</span>),fy2(<span class="built_in">i</span>)];</span><br><span class="line">   R(<span class="built_in">i</span>) = det(H&#123;<span class="built_in">i</span>&#125;) - <span class="number">0.04</span>*(trace(H&#123;<span class="built_in">i</span>&#125;))^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">w = <span class="number">3</span>;    <span class="comment">% 半窗宽</span></span><br><span class="line">label = <span class="built_in">zeros</span>(rows,cols);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>+w:rows-w    <span class="comment">% 在7×7邻域内进行非极大值抑制</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>+w:cols-w</span><br><span class="line">        <span class="keyword">if</span> R(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="built_in">max</span>(<span class="built_in">max</span>(R(<span class="built_in">i</span>-w:<span class="built_in">i</span>+w,<span class="built_in">j</span>-w:<span class="built_in">j</span>+w))) ...</span><br><span class="line">                &amp;&amp; R(<span class="built_in">i</span>,<span class="built_in">j</span>) &gt; <span class="number">0.01</span>*<span class="built_in">abs</span>(<span class="built_in">max</span>(R(:)))</span><br><span class="line">            label(<span class="built_in">i</span>,<span class="built_in">j</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[~,ind] = maxk(label(:).*R(:),n);    <span class="comment">% 找出前n个响应最强的点</span></span><br><span class="line">[x,y] = <span class="built_in">ind2sub</span>([rows,cols],ind);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>demo</code> ：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all; clear; clc;</span><br><span class="line">img = imread(<span class="string">&#x27;house.tif&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(img,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    img = rgb2gray(img);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">img = double(img);</span><br><span class="line">[x,y] = myHarris(img,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">figure</span>; imshow(img,[]);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(y,x,<span class="string">&#x27;r+&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">8</span>);</span><br><span class="line"><span class="comment">% 与自带函数对比</span></span><br><span class="line">corners = detectHarrisFeatures(img);</span><br><span class="line"><span class="built_in">figure</span>; imshow(img,[]); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(corners.selectStrongest(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="再附上-hessian-特征点检测的代码">再附上 <code>Hessian</code>
特征点检测的代码</h4>
<p><code>Hessian</code> 特征点检测是依靠 <code>Hessian</code>
矩阵的<strong>行列式</strong>来进行判断的</p>
<blockquote>
<p>注意，若行列式的值小于零，则表示 <code>Hessian</code>
矩阵是<strong>不定</strong>的（不满足各阶顺序主子式及各偶数阶顺序主子式大于零的正负定判断条件），此时该点<strong>不是极值点</strong>（即不是我们想要的特征点）</p>
</blockquote>
<p>因此 <code>Hessian</code> 特征点检测又称为 <code>DoH</code>
检测（我们认为 <code>DoH</code> 是一个类似于 <code>LoG</code> 和
<code>DoG</code> 的算子）</p>
<p><code>myDoH</code> 函数：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,y]</span> = <span class="title">myDoH</span><span class="params">(img,n)</span></span></span><br><span class="line">fxx = imfilter(img,[<span class="number">1</span>;<span class="number">-2</span>;<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fyy = imfilter(img,[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fxy = imfilter(img,[<span class="number">1</span>;<span class="number">0</span>;<span class="number">-1</span>]*[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]/<span class="number">4</span>,<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">[rows,cols] = <span class="built_in">size</span>(img);</span><br><span class="line">H = cell(rows,cols);</span><br><span class="line">R = <span class="built_in">zeros</span>(rows,cols);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(img)</span><br><span class="line">   H&#123;<span class="built_in">i</span>&#125; = [fxx(<span class="built_in">i</span>),fxy(<span class="built_in">i</span>);fxy(<span class="built_in">i</span>),fyy(<span class="built_in">i</span>)];</span><br><span class="line">   R(<span class="built_in">i</span>) = det(H&#123;<span class="built_in">i</span>&#125;);    <span class="comment">% 计算DoH</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">w = <span class="number">3</span>;    <span class="comment">% 半窗宽</span></span><br><span class="line">label = <span class="built_in">zeros</span>(rows,cols);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>+w:rows-w    <span class="comment">% 在7×7邻域内进行非极大值抑制</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>+w:cols-w</span><br><span class="line">        <span class="keyword">if</span> R(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="built_in">max</span>(<span class="built_in">max</span>(R(<span class="built_in">i</span>-w:<span class="built_in">i</span>+w,<span class="built_in">j</span>-w:<span class="built_in">j</span>+w))) ...</span><br><span class="line">                &amp;&amp; R(<span class="built_in">i</span>,<span class="built_in">j</span>) &gt; <span class="number">0.01</span>*<span class="built_in">abs</span>(<span class="built_in">max</span>(R(:)))</span><br><span class="line">            label(<span class="built_in">i</span>,<span class="built_in">j</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[~,ind] = maxk(label(:).*R(:),n);    <span class="comment">% 找出前n个响应最强的点</span></span><br><span class="line">[x,y] = <span class="built_in">ind2sub</span>([rows,cols],ind);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>demo</code> ：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all; clear; clc;</span><br><span class="line">img = imread(<span class="string">&#x27;house.tif&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(img,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    img = rgb2gray(img);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">img = double(img);</span><br><span class="line">[x,y] = myDoH(img,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">figure</span>; imshow(img,[]);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(y,x,<span class="string">&#x27;r+&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>仔细比较，体会二者的区别！</p>
<hr />
<h4 id="快速-doh-算法">快速 <code>DoH</code> 算法</h4>
<p>该算法用在 <code>SURF</code>
中，使用了盒式模板代替高斯二阶偏导模板，因为盒式模板与图像卷积可借助于<strong>积分图像</strong>进行快速运算</p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的函数参数类型</title>
    <url>/2022/04/11/python-zhong-de-han-shu-can-shu-lei-xing/</url>
    <content><![CDATA[<h4 id="位置参数">位置参数</h4>
<p>又叫顺序参数，在未指定参数名时，必须严格按照顺序来传递参数！（很简单）</p>
<hr />
<h4 id="默认参数">默认参数</h4>
<p>在函数定义的时候，如果给某个参数提供一个默认值，这个参数就变成了默认参数，不再是位置参数了。在调用函数时，既可以给默认参数传递一个自定义的值，也可以使用默认的值</p>
<p>默认参数必须定义在位置参数的后面</p>
<blockquote>
<p>重点，默认参数默认值为 <code>None</code> 的情况</p>
</blockquote>
<p>参考：<a
href="https://blog.csdn.net/weixin_40796925/article/details/107637505">Python
函数动态参数值设为 None 的意义</a></p>
<p>先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a=[]</span>):</span><br><span class="line">    a.append(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而不是</span></span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>为什么会这样？</p>
<blockquote>
<p>因为 <code>Python</code> 函数体在被读入内存的时候，默认参数
<code>a</code> 指向的空列表对象就会被创建，并放在内存里了。因为默认参数
<code>a</code> 本身也是一个变量，保存了指向对象 <code>[]</code>
的地址。每次调用该函数，就往指向 <code>a</code> 的列表里添加一个
<code>A</code> 。 <code>a</code>
是没有变的，它始终保存着指向列表的地址，变的是列表内的数据！详细测试请移步博客：<a
href="https://www.liujiangblog.com/course/python/31">刘江的博客：默认参数设置为
None 的情况</a></p>
</blockquote>
<p>若想要输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>则代码可以改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 注意下面的if语句</span></span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        a = []</span><br><span class="line">    a.append(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="built_in">print</span>(func())</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="动态参数">动态参数</h4>
<p>传入参数的个数是动态的（即<strong>数量不固定的</strong>），可以是
<code>0</code> 个、 <code>1</code> 个、 <code>2</code> 个、
<code>更多个</code> 甚至 <code>任意个</code>
，在不需要的时候，完全可以将动态参数当作空气而忽略它的存在。
<code>Python</code> 中的动态参数有两种，分别是 <code>*args</code> 和
<code>**kwargs</code> ，这里的关键是一个星号 <code>*</code> 和两个星号
<code>**</code> 的区别，而不是 <code>args</code> 和 <code>kwargs</code>
在名字上的区别，实际上可以使用 <code>*any</code> 或
<code>**whatever</code> 的任何命名方式，但就如 <code>self</code>
一样，使用 <code>*args</code> 和 <code>**kwagrs</code>
已经<strong>形成了一种不成文的规定</strong>，我们应当（最好）遵守它</p>
<ul>
<li><code>*args</code> 的作用</li>
</ul>
<blockquote>
<p>将传入的实际参数转换（<strong>打包</strong>）成一个<strong>元组</strong>后再传递给形式参数（一个列表当作一个参数）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">func([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>可以很清晰地看到， <code>args</code> 的值是一个元组。接下来看看其中
<code>*</code> 的作用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="built_in">print</span>(*args)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">func([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>至此，已经发现， <code>*args</code> 作为形参，其中起作用的就是
<code>*</code> 号（就像前面说的， <code>args</code>
可以换为任何其它字符串，但我们最好遵守这种命名习惯），它起到<strong>打包和解包</strong>的作用</p>
<p>既然 <code>*</code>
可以起到<strong>解包</strong>的作用，那么对于可迭代对象（如字符串、元组、列表）自然便可以起到<strong>拆分</strong>的效果（但只能拆分
<code>1</code> 层）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="built_in">print</span>(*<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span>(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">a b c</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>**kwargs</code> 的作用</li>
</ul>
<blockquote>
<p>将传入的实际参数（键-值对参数）转换（<strong>打包</strong>）成一个<strong>字典</strong>后再传递给形式参数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">    <span class="built_in">print</span>(**kwargs)</span><br><span class="line">    </span><br><span class="line">func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: (<span class="number">1</span>, <span class="number">2</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，查看 <code>**</code> 的功能（几乎同 <code>*</code>
理，故以下只进行简单测试）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">A, B, C</span>):</span><br><span class="line">	<span class="built_in">print</span>(A, B, C)</span><br><span class="line"></span><br><span class="line">func(**&#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>注意：直接使用 <code>A, B, C = **&#123;'A': 1, 'B': 2, 'C': 3&#125;</code> 或
<code>print(**&#123;'A': 1, 'B': 2, 'C': 3&#125;)</code> 是错误的！</p>
<p><code>*</code> 和 <code>**</code> 只有在传参时才起作用，即使
<code>print(*(1, 2, 3))</code> 有效，但
<code>a, b, c = *(1, 2, 3)</code> 是无效的！</p>
<ul>
<li>混合参数、万能参数 <code>*args</code> + <code>**kwargs</code>
的作用</li>
</ul>
<blockquote>
<p>要注意一点， <code>*args</code> 必须写在 <code>**kwargs</code>
的前面</p>
<p>当位置参数、默认参数、动态参数混合使用时，要注意默认参数是否被动态参数赋值！</p>
<p><a
href="https://www.liujiangblog.com/course/python/31">详见刘江的博客教程：混合使用时默认参数被覆盖的问题</a></p>
</blockquote>
<hr />
<h4 id="参考文章很实用">参考文章（很实用）</h4>
<p><a
href="https://www.liujiangblog.com/course/python/31">刘江的博客教程：
Python 教程</a></p>
<p><a href="https://www.jianshu.com/p/c0ce45122849">Python
动态参数的使用</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hough线变换</title>
    <url>/2022/03/09/hough-xian-bian-huan/</url>
    <content><![CDATA[<h4 id="一-hough-变换的参数平面-hough-平面">一、 $ Hough $
变换的参数平面（ $ Hough $ 平面）</h4>
<p>在图像平面（ $ Image Plan $ ）的坐标系 $ xOy $
中，直线方程的<strong>斜截式</strong>为： $ y = px + q $ ，其中 $ p $
为斜率， $ q $ 为截距</p>
<p>假设上式所代表的<strong>某条</strong>（ $ p q $ 任意 ）直线上存在一点
$ (x_{i},y_{i}) $ ，则此点满足 $ y_{i} = px_{i} + q $
，若将其改写，可变为 <span class="math display">\[
q = -x_{i}p + y_{i}
\]</span> 试想，此时若构造一个 $ pOq $ 坐标系，则 $ -x_{i} $ 为斜率， $
y_{i} $ 为截距，这是一条<strong>确定的直线</strong>！</p>
<p>换言之， $ Hough $
变换就是将图像平面的<strong>点</strong>映射为参数平面（ $
Parametric Plan $ ） 的<strong>线</strong>！</p>
<p>可以结合下图形象地理解：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/Hough/houghLines1.png" style="zoom: 67%;" /></p>
<p>此时，可以在图像空间中考虑另一个点 $ (x_{j},y_{j}) $ ，它与点 $
(x_{i},y_{i}) $ 共同确定一条直线 $ q_{0} = -p_{0}x + y $</p>
<p>因为这两点具有<strong>同样的</strong> $ p $ （斜率）和 $ q $
（截距），因此，二者在参数平面所代表的直线<strong>相交于同一点</strong>
$ (p_{0}, q_{0}) $</p>
<p>类似地，点 $ (x_{k},y_{k}) $ 所对应的直线也将经过点 $ (p_{0},q_{0}) $
！</p>
<p>由此得出一个直观的<strong>结论</strong>：</p>
<blockquote>
<p>图像平面中，同一条直线上的点在参数平面中所对应的线<strong>相交于一点</strong></p>
<p>并且这一点的坐标为（图像平面直线的<strong>斜率</strong>，图像平面直线的<strong>截距</strong>）</p>
</blockquote>
<hr />
<h4 id="二在-hough-平面中使用-voting-策略寻找直线">二、在 $ Hough $
平面中使用 $ voting $ 策略寻找直线</h4>
<p>在参数平面中，越多的直线相交于同一点 $ (p_{0},q_{0}) $
，那么在图像平面中就有越多的点位于直线 $ y = p_{0}x + q_{0} $
上，也就是说</p>
<p><strong>这条直线越像直线</strong>，<strong>这条直线比较明显</strong>，<strong>这条直线比较长</strong>，<strong>这条直线应该被认为是直线并且应该被标识出来</strong></p>
<p>那么，问题来了，怎么样才能知道这个点 $ (p_{0},q_{0}) $
被<strong>几条</strong>参数平面中的直线经过呢？ $ (p_{0},q_{0}) $
又应该取什么值呢？</p>
<p>$ Hough $
给出了一种<strong>遍历投票</strong>的解决办法，具体实现如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/Hough/houghLines2.png" style="zoom:67%;" /></p>
<p>（1）在 $ pOq $
坐标系中划分网格（网格的精度根据实际要求自行确定），坐标轴的范围应从实际的最小斜率变化到</p>
<p>最大斜率、从实际的最小截距变化到最大截距（ $ p_{min} $ 到 $ p_{max} $
， $ q_{min} $ 到 $ q_{max} $ ）</p>
<p>（2）对于图像平面中的点 $ (x_{i},y_{i}) $ ，遍历 $ p $ （ $ q $
也行）的所有<strong>网格取值</strong>，代入表达式 $ q = -x_{i}p + y_{i}$
中可得到</p>
<p>相应的 $ q $ （ $ p $
）值，该值落在哪一个小网格内，就为该网格<strong>投一票</strong></p>
<p>（3）遍历图像平面中所有的前景点，进行第（2）步操作，最终得到 $ pOq $
坐标系中所有网格的投票情况</p>
<p>（4）筛选投票数较多（大于设定阈值）的网格，该网格所代表的 $ p $ 和 $
q$ 值便在图像平面中确定了直线 $ y_{i} = px_{i} + q $​</p>
<hr />
<h4 id="三方法的特点以及局限性">三、方法的特点以及局限性</h4>
<h5 id="方法的特点">方法的特点：</h5>
<blockquote>
<p>如上右图所示，网格划分得越精细，容错率就越低，就越容易受噪声的影响，所找的直线数量就越多</p>
<p>相反，网格划分得越粗糙，容错率就越高，在一定程度上能克服噪声的影响，但所找的直线越不准确</p>
<p>因此，网格的划分精度往往取决于实际的需求，而且，挑选筛选直线的阈值也是一门技术活</p>
</blockquote>
<h5 id="方法的局限性">方法的局限性：</h5>
<blockquote>
<p>当图像平面中的直线接近<strong>竖直</strong>时， $ p $
的值将变得特别大或特别小，即 $ |p| $ 趋于无穷时， $ pOq $
平面将无法划分！</p>
<p>即使硬着头皮划分，计算机也会因庞大的计算量而内存溢出！</p>
<p>因此，传统意义上的 $ Hough $
线变换<strong>无法寻找竖直直线</strong>！</p>
</blockquote>
<hr />
<h4 id="四解决传统的-hough-线变换无法寻找竖直直线的问题">四、解决传统的
$ Hough $ 线变换无法寻找竖直直线的问题</h4>
<p>使用极坐标方程代替直角坐标方程即可完美地解决这个问题！首先观察下图 $
a) $ ：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/Hough/houghLines3.png" style="zoom:67%;" /></p>
<p>在图像平面中，过原点做一条与直线<strong>垂直</strong>的垂线，该垂线的所代表的<strong>方向向量</strong>可写为：
<span class="math display">\[
(\ \rho cos(\theta),\ \rho sin(\theta)\ )
\]</span> 设直线的方向向量为 $ (m,n) $ ，且经过点 $ (x_{i},y_{i}) $
，则其方程可写为： <span class="math display">\[
\frac{x-x_{i}}{m} = \frac{y-y_{i}}{n}
\]</span> 又因直线与垂线垂直，因此二者的方向向量满足： <span
class="math display">\[
(\ \rho cos(\theta),\ \rho sin(\theta)\ ) (m,\ n) =
m\rho cos(\theta) + n\rho sin(\theta) = 0
\]</span> 即： <span class="math display">\[
m\rho cos(\theta) = -n\rho sin(\theta) \\ \\
\frac{m}{n} = -\frac{\rho sin(\theta)}{\rho cos(\theta)}
\]</span> 故有： <span class="math display">\[
\frac{x-x_{i}}{y-y_{i}} = \frac{m}{n} = -\frac{\rho sin(\theta)}{\rho
cos(\theta)}
\]</span> 令： <span class="math display">\[
x_{i} = \rho cos(\theta) \;\;\;\; y_{i} = \rho sin(\theta)
\]</span> 代入，并化简整理，可得： <span class="math display">\[
\frac{x-\rho cos(\theta)}{y-\rho sin(\theta)} = -\frac{\rho
sin(\theta)}{\rho cos(\theta)} \\ \\
\rho cos(\theta)x - \rho^2cos^2(\theta) = \rho^2sin^2(\theta) - \rho
sin(\theta)y \\ \\
\rho cos(\theta)x + \rho sin(\theta)y = \rho^2cos^2(\theta)
+  \rho^2sin^2(\theta) = \rho^2 \\ \\
\rho = xcos(\theta) + ysin(\theta)
\]</span>
可以很明显地看出，在参数平面上，一个<strong>点</strong>映射成了一条<strong>正余弦曲线</strong>，并且横纵坐标轴的取值范围缩减为：
<span class="math display">\[
\rho \in [-D,D] \;\;\;\;\;\; \theta \in [-90^o,90^o]
\]</span> 其中 $ D $ 为图像平面中对角之间的最大距离</p>
<blockquote>
<p>寻找直线的<strong>遍历投票</strong>思想在这里是一样的，只不过参数平面交点的获得由<strong>直线相交</strong>变为了<strong>正余弦曲线相交</strong></p>
</blockquote>
<hr />
<h4 id="五一些-hough-线变换的实例建立直观感受">五、一些 $ Hough $
线变换的实例（建立直观感受）</h4>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/Hough/houghLines4.png" style="zoom:67%;" /></p>
<h4 id="六-hough-线变换的实现">六、 $ Hough $ 线变换的实现</h4>
<p>函数 <code>myHoughLine</code> 实现了 $ Hough $ 线变换，代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHoughLine</span><span class="params">(I,lineNum)</span></span></span><br><span class="line"><span class="comment">%% 参数说明</span></span><br><span class="line"><span class="comment">% I为灰度图像</span></span><br><span class="line"><span class="comment">% lineNum为要提取的直线数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Hough线变换</span></span><br><span class="line">BW = edge(I,<span class="string">&#x27;canny&#x27;</span>);    <span class="comment">% 提取边缘，以作为Hough线变换的前景</span></span><br><span class="line">[row,col] = <span class="built_in">size</span>(BW);</span><br><span class="line">D = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(row^<span class="number">2</span> + col^<span class="number">2</span>));    <span class="comment">% 图像平面的对角距离，为避免索引时超出数组边界，向上取整</span></span><br><span class="line">Rho = -D:D; Theta = <span class="number">-90</span>:<span class="number">90</span>;    <span class="comment">% 定义参数平面的取值范围</span></span><br><span class="line">Scores = <span class="built_in">zeros</span>(<span class="built_in">length</span>(Rho),<span class="built_in">length</span>(Theta));    <span class="comment">% 创建voting矩阵</span></span><br><span class="line">[x,y] = <span class="built_in">find</span>(BW == <span class="number">1</span>);    <span class="comment">% 取出前景像素作为voting点</span></span><br><span class="line">rho = <span class="built_in">round</span>(x.*<span class="built_in">cosd</span>(Theta) + y.*<span class="built_in">sind</span>(Theta));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(rho,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(Theta)</span><br><span class="line">        Scores(D + rho(<span class="built_in">i</span>,<span class="built_in">j</span>) + <span class="number">1</span>,<span class="built_in">j</span>) = Scores(D + rho(<span class="built_in">i</span>,<span class="built_in">j</span>) + <span class="number">1</span>,<span class="built_in">j</span>) + <span class="number">1</span>;    <span class="comment">% 遍历投票</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">lineMaxValue = maxk(Scores(:),lineNum);</span><br><span class="line">[lineRho,lineTheta] = <span class="built_in">find</span>(Scores &gt;= lineMaxValue(lineNum),lineNum);</span><br><span class="line">lineRho = lineRho - D - <span class="number">1</span>;    <span class="comment">% 记得转换回来</span></span><br><span class="line">lineTheta = lineTheta - <span class="number">90</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘制“最强的”lineNum条直线</span></span><br><span class="line"><span class="built_in">figure</span>; imshow(I); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:lineNum</span><br><span class="line">   n = <span class="number">0.05</span>*row:<span class="number">0.95</span>*row;</span><br><span class="line">   m = (-<span class="built_in">cosd</span>(lineTheta(k))*n + lineRho(k)) / <span class="built_in">sind</span>(lineTheta(k));</span><br><span class="line">   m(m &lt; <span class="number">0.05</span>*col | m &gt; <span class="number">0.95</span>*col) = NaN;    <span class="comment">% 绘制范围不要超过图像边界</span></span><br><span class="line">   <span class="built_in">plot</span>(m,n,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;Linewidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;clear;clc;tic;</span><br><span class="line">I = imread(<span class="string">&#x27;airport.tif&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(I,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    I = rgb2gray(I);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">myHoughLine(I,<span class="number">3</span>);toc;</span><br></pre></td></tr></table></figure>
<p>对一张机场航拍图进行主干道提取：</p>
<p><strong>这是原图（可以看出一共有3条主干道）</strong></p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/Hough/exam1.png" style="zoom: 67%;" /></p>
<p><strong>这是使用 $ Hough $ 线变换的提取结果图</strong></p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/Hough/exam2.png" style="zoom:67%;" /></p>
<h4 id="七附录-hough-圆变换">七、附录： $ Hough $ 圆变换</h4>
<p>$ Hough $
圆变换的思想与线变换是一致的，区别仅在于参数空间的维数不同。（ $ Hough $
圆变换的参数空间为 $ a,b,r $ 三维）</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/featureDetection/Hough/houghCircle.png" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>DIP中的Hessian矩阵</title>
    <url>/2022/04/13/dip-zhong-de-hessian-ju-zhen/</url>
    <content><![CDATA[<h4 id="从泰勒展开说起">从泰勒展开说起</h4>
<p>将一个一元函数 $ f(x) $ 在 $ x=x_{0} $ 处进行泰勒展开，可得： <span
class="math display">\[
f(x_{0} + \Delta x) = f(x_{0}) + f^{&#39;}(x_{0})\Delta x +
\frac{f^{&#39;&#39;}(x_{0})}{2!}\Delta x^{2} +
o\lVert\Delta x^{2}\rVert
\]</span> 同理，将一个二元函数（图像） $ f(x,y) $ 在 $ x=x_{0},y=y_{0} $
处进行泰勒展开，可得： <span class="math display">\[
f(x_{0} + \Delta x,y_{0} + \Delta y) = f(x_{0},y_{0}) +
(f_{x}(x_{0},y_{0})\Delta x + f_{y}(x_{0},y_{0})\Delta y) + \\
\frac{1}{2!}(f_{xx}(x_{0},y_{0})\Delta x^{2} +
2f_{xy}(x_{0},y_{0})\Delta x\Delta y + f_{yy}(x_{0},y_{0})\Delta y^{2})
+ o\lVert\Delta x^{2} + \Delta y^{2}\rVert
\]</span> 其中，我们假设混合二阶偏导数是相等的，即： <span
class="math display">\[
f_{xy}(x_{0},y_{0}) = f_{yx}(x_{0},y_{0})
\]</span> 将其改写成矩阵相乘的形式，有： <span class="math display">\[
f(x_{0} + \Delta x,y_{0} + \Delta y) = f(x_{0},y_{0})
+ \begin{pmatrix} f_{x}(x_{0},y_{0}) \\ f_{y}(x_{0},y_{0})\end{pmatrix}
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix} \\
+ \frac{1}{2!}\begin{pmatrix} \Delta x &amp; \Delta y\end{pmatrix}
\begin{pmatrix} f_{xx}(x_{0},y_{0}) &amp; f_{xy}(x_{0},y_{0} \\
f_{yx}(x_{0},y_{0}) &amp; f_{yy}(x_{0},y_{0})\end{pmatrix}
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}
+o\lVert\Delta x^{2} + \Delta y^{2}\rVert
\]</span> 使用“对应”的思想去理解，应有： <span class="math display">\[
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}\;\; 相当于 \;\;\Delta
x
\]</span></p>
<p><span class="math display">\[
\begin{pmatrix} \Delta x &amp; \Delta y\end{pmatrix}
\begin{pmatrix} \Delta x \\ \Delta y\end{pmatrix}\;\; 相当于 \;\;\Delta
x^{2}
\]</span></p>
<p><span class="math display">\[
\begin{pmatrix} f_{x}(x_{0},y_{0}) \\
f_{y}(x_{0},y_{0})\end{pmatrix}\;\; 相当于 \;\;f^{&#39;}(x_{0})
\]</span></p>
<p><span class="math display">\[
\begin{pmatrix} f_{xx}(x_{0},y_{0}) &amp; f_{xy}(x_{0},y_{0} \\
f_{yx}(x_{0},y_{0}) &amp; f_{yy}(x_{0},y_{0})\end{pmatrix}\;\; 相当于
\;\;f^{&#39;&#39;}(x_{0})
\]</span></p>
<p>即一元函数中的 <code>标量变量</code> 对应二元函数中的
<code>两元素向量变量</code> ，一元函数中的 <code>一阶导数斜率</code>
对应二元函数中的 <code>一阶导数梯度</code> ，一元函数中的
<code>二阶导数斜率变化率</code> 对应二元函数中的
<code>二阶导数Hessian矩阵（梯度变化率）</code>
，它是一种局部曲率（曲折度）的体现</p>
<blockquote>
<p>总之，我们应记住这样一个结论（不严格去纠结）： <code>Hessian</code>
矩阵就是 <code>二阶导数</code></p>
<p>而二阶导数在判定函数极值中的重要性是不言而喻的</p>
</blockquote>
<hr />
<h4 id="极值判定准则">极值判定准则</h4>
<ul>
<li>一元函数情形</li>
</ul>
<p>当一元函数 $ f(x) $ 在点 $ x=x_{0} $ 处的一阶导数 $ f^{'}(x_{0})=0 $
时：</p>
<ol type="1">
<li>若二阶导数 $ f^{''}(x_{0})&gt;0 $ ，则该点为
<code>极小值点</code></li>
<li>若二阶导数 $ f^{''}(x_{0})&lt;0 $ ，则该点为
<code>极大值点</code></li>
<li>若二阶导数 $ f^{''}(x_{0})=0 $ ，则该点 <code>无法判断</code></li>
</ol>
<ul>
<li>二元函数情形</li>
</ul>
<p>当二元函数 $ f(x,y) $ 在点 $ (x_{0},y_{0}) $
处的一阶导数（即梯度向量）为零时：</p>
<ol type="1">
<li>若 <code>Hessian</code> 矩阵正定，即二阶导数值大于零，则该点为
<code>极小值点</code></li>
<li>若 <code>Hessian</code> 矩阵负定，即二阶导数值小于零，则该点为
<code>极大值点</code></li>
<li>若 <code>Hessian</code>
矩阵半正定或半负定（其它特征值都为正或负，但是至少有一个特征值为零），则该点
<code>无法判断</code></li>
<li>若至少有一个特征值大于零，且至少有一个特征值小于零，那么在大于零的特征值所对应的截面上有极小值，在小于零的特征值所对应的截面上有极大值，实际的二维曲面可以联想
<code>马鞍面</code> ，该特殊点即为 <code>鞍点</code>
（该点不是极值点）</li>
</ol>
<ul>
<li>二维 <code>Hessian</code> 矩阵正定性的判定</li>
</ul>
<ol type="1">
<li>正定：两阶顺序主子式都大于零，即要求
<code>两个特征值都大于零</code></li>
<li>负定：一阶顺序主子式小于零，二阶顺序主子式大于零，即要求
<code>两个特征值都小于零</code></li>
<li>半正定：一个或两个特征值为零，可以检查该函数是否为常值函数或该函数在某一个维度上是否为常值</li>
<li>鞍点：一个特征值大于零，另一个特征值小于零（该点不是极值点）</li>
</ol>
<hr />
<h4 id="二维-hessian-矩阵和椭圆">二维 <code>Hessian</code>
矩阵和椭圆</h4>
<p>一般形式的二元二次方程是双曲线方程，即： <span
class="math display">\[
a_{11}x^{2} + a_{22}y^{2} + (a_{12}+a_{21})xy = 1
\]</span> 写成矩阵的形式为： <span class="math display">\[
\begin{pmatrix}x &amp; y\end{pmatrix}\begin{pmatrix} a_{11} &amp; a_{12}
\\ a_{21} &amp; a_{22}\end{pmatrix}\begin{pmatrix}x \\ y\end{pmatrix} =
1
\]</span> 当 $ a_{11},a_{22} $
同号时，该方程就变为一个椭圆方程，而且，椭圆的大小、形状、方位全由
<code>实对称矩阵</code> 决定</p>
<p>也就是说，该 <code>实对称矩阵</code>
的特征值和特征向量与椭圆的大小、形状、方位有着密切的关系</p>
<blockquote>
<p>事实上，矩阵的两个特征向量的方向分别对应着椭圆的长短轴的方向</p>
<p>而矩阵的两个特征值分别对应着椭圆的半短轴、半长轴的平方的倒数</p>
<p>大特征值及其特征向量对应着椭圆的短轴，小特征值及其特征向量对应着椭圆的长轴（因为存在倒数关系）</p>
</blockquote>
<p>具体可参看下图理解：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFeature/Hessian/Hessian.png" style="zoom: 67%;" /></p>
<hr />
<h4 id="和图像的联系">和图像的联系</h4>
<p><code>Hessian</code>
矩阵可以量化图像中的“平坦区域”、“边缘”和“角”之间的差异，它体现了梯度的局部变化率（即梯度变化的快慢，又称局部曲率、局部曲折度），见下图：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFeature/Hessian/Harris1.png" style="zoom:67%;" /></p>
<p>某点的 <code>Hessian</code>
矩阵的特征值及特征向量可以很好地帮助我们判断图像的特征：</p>
<ul>
<li>若两个特征值同号且值都较大，那么该点很有可能是斑点或者角点
<ol type="1">
<li>都大于零，则为黑斑点或黑角点</li>
<li>都小于零，则为亮斑点或亮角点</li>
</ol></li>
<li>若两个特征值同号且值都较小，那么该点很有可能位于平坦区域</li>
<li>若两个特征值同号且一个值较大一个值较小，那么该点很有可能位于边缘，且大特征值对应于垂直边缘的特征向量</li>
</ul>
<p>详见以下图解：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFeature/Hessian/Harris2.png" style="zoom:67%;" /></p>
<hr />
<h4 id="图像中-hessian-矩阵的计算">图像中 <code>Hessian</code>
矩阵的计算</h4>
<p>对于一幅图像 $ f(x,y) $ ，其 <code>Hessian</code> 矩阵可以表示为：
<span class="math display">\[
\begin{pmatrix} \frac{\partial^{2} f}{\partial x^{2}} &amp;
\frac{\partial^{2} f}{\partial x \partial y} \\ \frac{\partial^{2}
f}{\partial y \partial x} &amp; \frac{\partial^{2} f}{\partial
x^{2}})\end{pmatrix}
\]</span> 其中：（一阶导数都是按中心差分计算的） <span
class="math display">\[
\frac{\partial^{2} f}{\partial x^{2}} = f(x+1,y) + f(x-1,y) -2f(x,y)
\]</span></p>
<p><span class="math display">\[
\frac{\partial^{2} f}{\partial y^{2}} = f(x,y+1) + f(x,y-1) -2f(x,y)
\]</span></p>
<p><span class="math display">\[
\frac{\partial^{2} f}{\partial x \partial y}
= \frac{\partial^{2} f}{\partial y \partial x}
= \frac{[f(x-1,y-1) + f(x+1,y+1)] - [f(x-1,y+1) + f(x+1,y-1)]}{4}
\]</span></p>
<hr />
<h4 id="参考文章">参考文章</h4>
<p><a href="https://zhuanlan.zhihu.com/p/377754969">Hessian
矩阵和极值判断</a></p>
<p><a
href="https://www.zhihu.com/question/47033644/answer/112864757">矩阵特征值和椭圆长短轴的关系</a></p>
<p><a
href="https://blog.csdn.net/qq_34562355/article/details/109225384">Hessian
矩阵（黑塞矩阵）</a></p>
<p><a href="https://en.wikipedia.org/wiki/Hessian_matrix">维基百科：
Hessian 矩阵</a></p>
<p><a
href="https://milania.de/blog/Introduction_to_the_Hessian_feature_detector_for_finding_blobs_in_an_image">一个国外大佬的博客</a></p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的生成器和迭代器</title>
    <url>/2022/04/12/python-zhong-de-sheng-cheng-qi-he-die-dai-qi/</url>
    <content><![CDATA[<p>好文链接：</p>
<p><a
href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128">廖雪峰的官方网站：生成器</a></p>
<p><a
href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640">廖雪峰的官方网站：迭代器</a></p>
<p><a
href="https://www.liujiangblog.com/course/python/38">刘江的博客教程：生成器</a></p>
<p><a
href="https://www.liujiangblog.com/course/python/37">刘江的博客教程：迭代器</a></p>
<p>个人尝试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器可直接通过将列表生成式的[]改为()得到</span></span><br><span class="line"><span class="comment"># 用yield关键字将一个函数标识为一个生成器</span></span><br><span class="line"><span class="comment"># 如实现斐波那契数列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="comment"># print(b)</span></span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用next()函数调用</span></span><br><span class="line"><span class="comment"># 调用fib()并非返回原函数的返回值，而是返回一个生成器对象</span></span><br><span class="line">gene = fib(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(gene))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gene))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gene))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gene))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gene))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gene))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gene))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须新创建一个生成器对象</span></span><br><span class="line"><span class="comment"># 继续使用gene会抛出StopIteration异常</span></span><br><span class="line">gene2 = fib(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 使用for循环调用</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> gene2:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查某种类型是否是”可迭代的“</span></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>([], Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(&#123;&#125;, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ”可迭代的“和”可迭代对象“是两种完全不同的东西</span></span><br><span class="line"><span class="comment"># 列表、元组等是”可迭代的“，但却不是”可迭代对象“，它们无法被next()方法调用</span></span><br><span class="line"><span class="comment"># 使用iter()函数将”可迭代的“类型转化成为”可迭代对象“</span></span><br><span class="line"><span class="comment"># 生成器天然就是”可迭代对象“，也就是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>([], Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator))</span><br></pre></td></tr></table></figure>
<p>上述代码输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;generator&#x27;</span>&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的生成式（推导式）</title>
    <url>/2022/04/12/python-zhong-de-sheng-cheng-shi-tui-dao-shi/</url>
    <content><![CDATA[<h4 id="列表生成式">列表生成式</h4>
<p>先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">lis = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p>上面的<strong>一行</strong>语句等效于下面的 <code>for</code>
循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以上列表生成式具有下面的逻辑：</span></span><br><span class="line"><span class="comment"># 首先执行for循环，对于每一个x，计算(x * x)的值</span></span><br><span class="line"><span class="comment"># 将这些值按序添加到一个新列表lis当中</span></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">lis = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    lis.append(i * i)</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p>再来看看一些进阶用法：</p>
<ul>
<li>在 <code>for</code> 后面使用 <code>if</code> 语句，表示筛选（过滤）
<code>x</code> 的条件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只操作x&lt;=5时的x</span></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">lis = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">if</span> x &lt;= <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>for</code> 前面使用 <code>if</code>
语句，表示改变生成新列表中值的方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当x&lt;=5时，计算x*x；当x&gt;5时，计算x</span></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">lis = [x * x <span class="keyword">if</span> x&lt;= <span class="number">5</span> <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用多层 <code>for</code> 循环（和单层循环是一个意思，
<code>3</code> 层及 <code>3</code>
层以上的循环在生成式（推导式）中就用得比较少了）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">lis = [x * y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用多个变量来生成列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">lis = [a+b+c <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&quot;p&quot;</span> <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;i&quot;</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;g&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;pig&#x27;</span>]</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="字典生成式">字典生成式</h4>
<p>个人感觉这个没有列表生成式实用，但还是了解一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">dic = &#123;x : y * y <span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="string">&quot;pig&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;dog&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;cat&quot;</span>, <span class="number">3</span>)]&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="string">&#x27;pig&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;dog&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="集合生成式">集合生成式</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，集合是无序不重复的</span></span><br><span class="line"><span class="comment"># 相比于字典，没有键-值对结构</span></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;abracadabra&quot;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="元组生成式">元组生成式？</h4>
<p>事实上不存在元组推导式，详情参看：<a
href="https://www.liujiangblog.com/course/python/36">刘江的博客教程：元组生成式？</a></p>
<p>其它参考：<a
href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017317609699776">廖雪峰的官方网站：列表生成式</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的装饰器</title>
    <url>/2022/04/11/python-zhong-de-zhuang-shi-qi/</url>
    <content><![CDATA[<p>首先奉上几篇写得很好的博文：</p>
<p><a
href="https://www.liujiangblog.com/course/python/39">刘江的博客教程：
Python 装饰器</a></p>
<p><a
href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584">廖雪峰的官方网站：
Python 装饰器</a></p>
<p><a href="https://foofish.net/python-decorator.html">理解 Python
装饰器看这一篇就够了</a></p>
<p>以下是本人写的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个带参数的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outermost</span>(<span class="params">form</span>):</span><br><span class="line">    <span class="built_in">print</span>(form)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第一个装饰器！&quot;</span>)</span><br><span class="line">            value = func(*args, **kwargs)    <span class="comment"># 执行foo必不可少</span></span><br><span class="line">            <span class="keyword">return</span> value    <span class="comment"># 需要用到foo的返回值时必不可少</span></span><br><span class="line">        <span class="keyword">return</span> inner    <span class="comment"># 必不可少</span></span><br><span class="line">    <span class="keyword">return</span> outer    <span class="comment"># 必不可少</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个带参数的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outermost2</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">outer2</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第二个装饰器！&quot;</span>)</span><br><span class="line">            value2 = func(*args, **kwargs)    <span class="comment"># 执行foo必不可少</span></span><br><span class="line">            <span class="keyword">return</span> value2    <span class="comment"># 需要用到foo的返回值时必不可少</span></span><br><span class="line">        <span class="keyword">return</span> inner2    <span class="comment"># 必不可少</span></span><br><span class="line">    <span class="keyword">return</span> outer2    <span class="comment"># 必不可少</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@outermost(<span class="params">form=<span class="string">&quot;函数功能：求两个数的立方和&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@outermost2(<span class="params">name=<span class="string">&quot;代码由chubbylhao编写&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 初始函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c=<span class="number">2</span></span>):</span><br><span class="line">    res = a**c + b**c</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;计算结果是%d&quot;</span> % res)</span><br><span class="line">    <span class="keyword">return</span> res**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">bar = foo(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算结果的平方是%d&quot;</span> % bar)</span><br></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数功能：求两个数的立方和</span><br><span class="line">代码由chubbylhao编写</span><br><span class="line">第一个装饰器！</span><br><span class="line">第二个装饰器！</span><br><span class="line">计算结果是<span class="number">9</span></span><br><span class="line">计算结果的平方是<span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>在不清楚（或忘记）装饰器的用法时，回头跑一跑上面的代码就都清晰了</p>
<p>~~多写写测试代码，检查逻辑问题</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python杂碎知识点</title>
    <url>/2022/04/13/python-za-sui-zhi-shi-dian/</url>
    <content><![CDATA[<h4 id="关于进程和线程">关于进程和线程</h4>
<p><code>多进程</code> 和 <code>多线程</code> 是实现 <code>多任务</code>
最常用的两种方式</p>
<p><code>进程</code> 是由 <code>若干线程</code> 组成的，
<code>一个进程</code> 至少有 <code>一个线程</code></p>
<p><code>多任务</code> 可以由 <code>多进程</code> 完成，也可以由
<code>一个进程</code> 内的 <code>多线程</code> 完成</p>
<h4 id="关于类">关于类</h4>
<p><code>object</code> 类是 <code>Python3</code>
中所有类的基类（父类）</p>
<h4 id="有关一些文件类型">有关一些文件类型</h4>
<p><code>.pxd</code> 文件是由 <code>Cython</code> 语言编写的
<code>Python</code> 扩展模块<strong>头文件</strong></p>
<p><code>.pxd</code> 文件类似于 <code>C</code> 语言的 <code>.h</code>
头文件， <code>.pxd</code> 文件中有 <code>Cython</code> 模块要包含的
<code>Cython</code> <strong>声明（或代码段）</strong></p>
<p><code>.pyx</code> 文件是由 <code>Cython</code> 语言编写的
<code>Python</code> 扩展模块<strong>源代码文件</strong></p>
<p><code>.pyx</code> 文件类似于 <code>C</code> 语言的 <code>.c</code>
源代码文件， <code>.pyx</code> 文件中有 <code>Cython</code>
模块的<strong>源代码</strong></p>
<blockquote>
<p>不像 <code>Python</code> 语言可直接解释使用的 <code>.py</code> 文件，
<code>.pyx</code> 文件必须先被编译成 <code>.c</code> 文件，再被编译成
<code>.pyd</code> ( <code>Windows</code> 平台)或 <code>.so</code> （
<code>Linux</code> 平台）文件，才可作为模块被 <code>import</code>
导入使用</p>
</blockquote>
<p><code>Python</code> 要导入 <code>.pyd</code> 文件，实际上是在
<code>.pyd</code> 文件中封装了一个 <code>module</code> 。在
<code>Python</code> 中使用时，把它当成模块 <code>import</code> 就好</p>
<h4 id="其它">其它</h4>
<p><a
href="https://www.polarxiong.com/archives/Python-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%B8%AD%E5%8D%95%E4%B8%AA%E6%98%9F%E5%8F%B7%E7%9A%84%E6%84%8F%E6%80%9D-Keyword-Only-Arguments.html">Python:
函数参数列表中单个星号的意思，Keyword-Only Arguments</a></p>
<p><span class="citation"
data-cites="可以用于表示矩阵乘法运算符">@可以用于表示矩阵乘法运算符</span></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo和GitHub_Pages搭建个人博客</title>
    <url>/2022/03/05/shi-yong-hexo-he-github-pages-da-jian-ge-ren-bo-ke/</url>
    <content><![CDATA[<h4
id="一为-github-pages-的使用建立一个仓库本文仅针对-windows-系统且为最简入门配置">一、为
GitHub Pages 的使用建立一个仓库（本文仅针对 Windows
系统，且为<font color="#dd0000">最简入门配置</font>）</h4>
<p>在 GitHub 中，新建一个仓库，注意仓库名应为
<strong>githubname.githubname.io</strong> ，其中 githubname 为自己的
GitHub 账户名</p>
<hr />
<h4 id="二使用-hexo-博客框架的前期准备">二、使用 Hexo
博客框架的前期准备</h4>
<p>（1）安装 <a href="https://nodejs.org/en/">Node.js</a>
（除修改安装目录外，其余无脑 next ）</p>
<p>（2）安装 <a href="https://git-scm.com/download/win">Git</a>
版本控制工具 （除修改安装目录外，其余无脑 next ）</p>
<blockquote>
<p>以上两个软件在安装时，均将<strong>添加环境变量</strong>纳入了默认选项</p>
</blockquote>
<p>（3）配置 Git ：</p>
<p>1、启动 Git Bash ，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>若最终显示：（则说明 Git 安装成功！）</p>
<p><img src="https://raw.githubusercontent.com/hugelhao/myPics/main/blogsPics/Git.png" alt="确认Git已经安装成功" style="zoom:80%;" /></p>
<p>2、为了把本地仓库中的内容上传到 GitHub 上，需要先配置 <strong>ssh
key</strong> ，它是一个 token ，作用是验证上传者的身份</p>
<p>紧接着上一步，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email&quot;</span>    <span class="comment"># email是注册Github时所使用的邮箱，其实也可以直接运行此命令（email不用改）</span></span><br></pre></td></tr></table></figure>
<p>3、接下来连续按 <strong>3</strong> 次回车 <strong>Enter</strong>
键，在路径 C:.ssh 文件夹下会生成一个名为 <strong>id_rsa.pub</strong>
的文件，使用</p>
<p>记事本或者 Notepad++ 等文本编辑器打开，复制里面的内容（该串字符即为
<strong>ssh key</strong> ）</p>
<p>4、找到已经建好的 <strong>githubname.githubname.io</strong>
仓库，点击 <strong>Settings</strong> ，在页面的左侧栏中找到
<strong>Deploy keys</strong> 并点击，接</p>
<p>下来选择 <strong>Add deploy key</strong>
按钮，取一个你觉得好听的名字填在 <strong>Title</strong>
中，并将上面已经复制的 <strong>ssh key</strong>填入
<strong>Key</strong>，最后保存</p>
<p>5、在本地验证 <strong>ssh key</strong>
设置已经成功：（紧接着上一个命令，输入即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>若最终显示：（则说明 <strong>ssh key</strong>
设置成功，当前已经成功地连接上了自己的 GitHub 账户）</p>
<p><img src="https://raw.githubusercontent.com/hugelhao/myPics/main/blogsPics/ssh_key.png" alt="设置ssh key" style="zoom:80%;" /></p>
<p>6、接下来，设置自己的用户名和邮箱并查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;my_github_name&quot;</span>    <span class="comment"># my_github_name换成自己的用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;my_github_email&quot;</span>    <span class="comment"># my_github_email换成自己的邮箱</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确认是否成功设置（若成功，将显示你的用户名和邮箱号）</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="三安装hexo">三、安装Hexo</h4>
<p>（1）Hexo 项目必须位于一个单独的文件夹中，在 Git Bash
中按如下命令可创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> D:\Github\hexo_next</span><br><span class="line"><span class="built_in">cd</span> D:\Github\hexo_next</span><br><span class="line">npm install hexo -g    <span class="comment"># 使用npm命令安装Hexo,-g代表全局安装</span></span><br></pre></td></tr></table></figure>
<p>（2）安装完成后，可通过以下命令检验：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>若最终显示：（则说明 <strong>Hexo</strong> 安装成功！）</p>
<p><img src="https://raw.githubusercontent.com/hugelhao/myPics/main/blogsPics/hexo.png" alt="Hexo安装成功" style="zoom:80%;" /></p>
<p>（3）搭建本地测试环境，首先 cd 到 hexo_next / 目录下，在 Git Bash
中输入：</p>
<p><code>hexo generate</code>命令用于生成静态文件，一般可以简写为<code>hexo g</code></p>
<p><code>hexo server</code>命令用于启动本地服务器，一般可以简写为<code>hexo s</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init    <span class="comment"># 初始化</span></span><br><span class="line">npm install    <span class="comment"># 安装Hexo所需要的组件</span></span><br><span class="line">hexo g    <span class="comment"># 产生webapp文件</span></span><br><span class="line">hexo s    <span class="comment"># 开启服务器</span></span><br></pre></td></tr></table></figure>
<p>当显示如下信息时，点击其中的链接<a
href="http://localhost:4000/">本地链接</a>，在浏览器可以打开本地博客服务</p>
<p><img src="https://raw.githubusercontent.com/hugelhao/myPics/main/blogsPics/starts.png" alt="确认本地服务器启动成功" style="zoom:80%;" /></p>
<hr />
<h4 id="四连接-hexo-和-github-pages">四、连接 Hexo 和 Github Pages</h4>
<p>（1）打开 D:_next_config.yml 文件，找到 <strong>deploy</strong>
字段，改为如下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:githubname/githubname.github.io.git</span><br><span class="line">    branch: main</span><br></pre></td></tr></table></figure>
<p>（2）最后再完成一个扩展插件的安装：（ cd 到 hexo_next / 目录下）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>（3）到此为止就可以进行首次部署了，紧接着上次命令键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>此时可以在浏览器输入地址 <strong>githubname.github.io</strong> 确认
Hexo 是否链接到 GitHub Pages</p>
<hr />
<h4 id="五将博客发布到-github-上">五、将博客发布到 Github 上</h4>
<p>（1）在 Markdown
编辑器中完成博客的编写后，应养成先在本地预览的好习惯</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s    <span class="comment"># 每次预览时清理一下缓存是很有必要的</span></span><br></pre></td></tr></table></figure>
<p>其中，默认的服务器端口号为 4000</p>
<p>（2）博客在本地预览无误后，在 Git Bash 命令窗口（ cd 到 hexo_next /
目录下）执行以下命令：</p>
<p><code>hexo clean</code>命令用于清理缓存文件</p>
<p><code>hexo deploy</code>命令用于部署网站，一般可以简写为<code>hexo d</code></p>
<p><code>hexo g &amp;&amp; hexo d</code>与<code>hexo d -g</code>等价</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d    <span class="comment"># 推荐使用</span></span><br><span class="line"><span class="comment"># 下面为简写</span></span><br><span class="line">hexo clean &amp;&amp; hexo d -g</span><br></pre></td></tr></table></figure>
<p>（3）在浏览器中访问自己的博客域名，查看文章是否发布成功（注：网页更新有一定的延迟，请耐心等待几秒！）</p>
<hr />
<h4 id="六参考资料">六、参考资料</h4>
<blockquote>
<p>该文章是本人的第一篇博客，略显粗糙（对我来说是一种新的尝试！）</p>
<p>关于 Hexo
框架更精细的使用，请参考以下链接所指的文章（感谢下面所有的文章作者！）</p>
</blockquote>
<p>（1） <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></p>
<p>（2）<a
href="https://liuchang.men/2019/03/20/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0Hexo(NexT%E4%B8%BB%E9%A2%98)%20+%20GitHub%20Pages/">生命不止，奋斗不息的博客</a></p>
<p>（3）<a
href="https://zhuanlan.zhihu.com/p/269331571">石鹏的博客</a></p>
<p>（4）<a
href="https://zhuanlan.zhihu.com/p/96641789">菜鸟程序员的博客</a></p>
<p>（5）<a
href="https://blog.csdn.net/wsmrzx/article/details/81478103">半虹的博客</a></p>
<p>（6）<a
href="https://segmentfault.com/a/1190000021614307">白小白的博客<strong>（超详细）</strong></a></p>
<p>（7）<a href="https://hexo-next.readthedocs.io/zh_CN/latest/">另一份
Hexo 中文文档<strong>（也超详细</strong>）</a></p>
<blockquote>
<p>配置过程中可能会遇到一些小问题，但是基本都能依靠 Google 解决</p>
<p>是吧，屏幕前的优秀大学生！</p>
</blockquote>
]]></content>
      <categories>
        <category>环境搭建</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于图像中的导数问题</title>
    <url>/2022/04/14/guan-yu-tu-xiang-zhong-de-dao-shu-wen-ti/</url>
    <content><![CDATA[<p>在图像处理的过程中，对其求导数是十分常见的事情：</p>
<ul>
<li>如求图像中某点的梯度（含一阶导数）</li>
<li>如求图像中某点的拉普拉斯响应（含二阶纯偏导数）</li>
<li>再如求图像中某点的 <code>Hessian</code>
矩阵（含二阶混合偏导数）</li>
</ul>
<hr />
<h4 id="一些重要的声明">一些重要的声明</h4>
<ul>
<li>对于边缘点求导像素值缺省的问题，优先建议使用 <code>复制填充</code>
方式，其次是 <code>零填充</code> 方式</li>
<li>针对图像而言，它的 <code>两个混合偏导数一定相等</code>
（本人已推导证明）</li>
<li>在图像中， <code>求导数和求卷积可交换顺序</code> ，例如：
<ul>
<li>用高斯偏导核去卷积一幅图像等价于图像先做高斯滤波再求梯度</li>
<li>用高斯二阶偏导核（ <code>LoG</code>
算子）去卷积一幅图像等价于图像先做高斯滤波再求拉普拉斯响应</li>
<li>一般而言，我们都是<strong>先高斯滤波，再进行求导数操作</strong>（而不是对高斯算子进行求导数操作），因为这样更加符合认知，不容易出错（实现难度也减小了不少）</li>
</ul></li>
<li>一般来说，认为 <code>x</code> 方向就是图像 <code>行</code> 的方向，
<code>y</code> 的方向就是图像 <code>列</code>
的方向（参考冈萨雷斯的教材）</li>
<li>一般来说，都是直接使用 <code>相关性</code> 代替 <code>卷积</code>
进行滤波，这样做是没问题的</li>
</ul>
<hr />
<h4 id="求导数的具体表达式">求导数的具体表达式</h4>
<blockquote>
<p>中心差分的误差相对于前向、后向差分的误差更小，因此优先考虑使用中心差分（来求导数）</p>
</blockquote>
<h5
id="一前向后向差分不涉及二阶导时可使用">一、前向、后向差分（不涉及二阶导时可使用）</h5>
<ul>
<li>前向差分：</li>
</ul>
<p><span class="math display">\[
\frac{\partial f}{\partial x} = f(x+1,y) - f(x,y)\;\;,
\;\;\frac{\partial f}{\partial y} = f(x,y+1) - f(x,y)
\]</span></p>
<ul>
<li>后向差分：</li>
</ul>
<p><span class="math display">\[
\frac{\partial f}{\partial x} = f(x,y) - f(x-1,y)\;\;,
\;\;\frac{\partial f}{\partial y} = f(x,y) - f(x,y-1)
\]</span></p>
<h5
id="二中心差分建议使用使用-taylor-展开导出">二、中心差分（建议使用，使用
<code>Taylor</code> 展开导出）</h5>
<ul>
<li>一阶中心差分：</li>
</ul>
<p><span class="math display">\[
\frac{\partial f}{\partial x} = \frac{f(x+1,y) - f(x-1,y)}{2}\;\;,
\;\;\frac{\partial f}{\partial y} = \frac{f(x,y+1) - f(x,y-1)}{2}
\]</span></p>
<ul>
<li>二阶纯偏导中心差分：</li>
</ul>
<p><span class="math display">\[
\frac{\partial^{2} f}{\partial x^{2}} = f(x+1,y) + f(x-1,y)
-2f(x,y)\;\;,
\;\;\frac{\partial^{2} f}{\partial y^{2}} = f(x,y+1) + f(x,y-1) -2f(x,y)
\]</span></p>
<ul>
<li>二阶混合偏导中心差分（偏导必相等）：</li>
</ul>
<p><span class="math display">\[
\frac{\partial^{2} f}{\partial x \partial y}
= \frac{\partial^{2} f}{\partial y \partial x}
= \frac{[f(x-1,y-1) + f(x+1,y+1)] - [f(x-1,y+1) + f(x+1,y-1)]}{4}
\]</span></p>
<hr />
<h4 id="实际应用">实际应用</h4>
<ul>
<li>梯度幅值算子：（若 <code>f</code> 是高斯函数，则为高斯偏导核）</li>
</ul>
<blockquote>
<p>使用高斯偏导核卷积图像求梯度幅值 = 图像先高斯滤波，再求梯度幅值</p>
</blockquote>
<p><span class="math display">\[
\lvert \frac{\partial f}{\partial x} \rvert + \lvert \frac{\partial
f}{\partial y} \rvert
\]</span></p>
<ul>
<li>拉普拉斯算子：（若 <code>f</code>
是高斯函数，则为高斯二阶偏导核）</li>
</ul>
<blockquote>
<p>使用高斯二阶偏导核卷积图像 = 图像先高斯滤波，再求拉普拉斯响应</p>
</blockquote>
<p><span class="math display">\[
\frac{\partial^{2} f}{\partial x^{2}} + \frac{\partial^{2} f}{\partial
y^{2}}
\]</span></p>
<ul>
<li><code>Hessian</code> 矩阵：</li>
</ul>
<blockquote>
<p><code>Hessian</code>
矩阵是针对于图像中的<strong>某个</strong>具体像素而言的</p>
<p>它分为使用邻域信息和不使用邻域信息两种</p>
<p>使用邻域信息又分为盒式平均和高斯平均两种</p>
</blockquote>
<p><span class="math display">\[
\begin{pmatrix} \frac{\partial^{2} f}{\partial x^{2}} &amp;
\frac{\partial^{2} f}{\partial x \partial y} \\ \frac{\partial^{2}
f}{\partial y \partial x} &amp; \frac{\partial^{2} f}{\partial
x^{2}})\end{pmatrix}
\]</span></p>
<h4 id="图像-hessian-矩阵的三种求法">图像 <code>Hessian</code>
矩阵的三种求法</h4>
<blockquote>
<p>图像中的每一个像素点都能求出它的 <code>Hessian</code> 矩阵</p>
<p>要注意一点： <code>Harris</code>
角点检测算法中的矩阵使用的是一阶导数，不是 <code>Hessian</code> 矩阵</p>
</blockquote>
<ul>
<li>不使用邻域信息的 <code>Hessian</code> 矩阵</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all; clear; clc;</span><br><span class="line">img = imread(<span class="string">&#x27;lena.tif&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(img,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    img = rgb2gray(img);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">img = double(img);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 不使用邻域信息的Hessian矩阵</span></span><br><span class="line">fxx = imfilter(img,[<span class="number">1</span>;<span class="number">-2</span>;<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fyy = imfilter(img,[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fxy = imfilter(img,[<span class="number">1</span>;<span class="number">0</span>;<span class="number">-1</span>]*[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]/<span class="number">4</span>,<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fyx = fxy;</span><br><span class="line">H = cell(<span class="built_in">size</span>(img));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(img)</span><br><span class="line">   H&#123;<span class="built_in">i</span>&#125; = [fxx(<span class="built_in">i</span>),fxy(<span class="built_in">i</span>);fyx(<span class="built_in">i</span>),fyy(<span class="built_in">i</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>3×3</code> 邻域信息的 <code>Hessian</code>
矩阵（使用盒式核滤波）</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all; clear; clc;</span><br><span class="line">img = imread(<span class="string">&#x27;lena.tif&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(img,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    img = rgb2gray(img);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">img = double(img);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用3×3邻域信息的Hessian矩阵（使用盒式核滤波）</span></span><br><span class="line">h = fspecial(<span class="string">&#x27;average&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">blur_img = imfilter(img,h,<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fxx = imfilter(blur_img,[<span class="number">1</span>;<span class="number">-2</span>;<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fyy = imfilter(blur_img,[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fxy = imfilter(blur_img,[<span class="number">1</span>;<span class="number">0</span>;<span class="number">-1</span>]*[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]/<span class="number">4</span>,<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fyx = fxy;</span><br><span class="line">H = cell(<span class="built_in">size</span>(img));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(img)</span><br><span class="line">   H&#123;<span class="built_in">i</span>&#125; = [fxx(<span class="built_in">i</span>),fxy(<span class="built_in">i</span>);fyx(<span class="built_in">i</span>),fyy(<span class="built_in">i</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>3×3</code> 邻域信息的 <code>Hessian</code>
矩阵（使用高斯核滤波）</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all; clear; clc;</span><br><span class="line">img = imread(<span class="string">&#x27;lena.tif&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(img,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    img = rgb2gray(img);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">img = double(img);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用3×3邻域信息的Hessian矩阵（使用高斯核滤波）</span></span><br><span class="line">h = fspecial(<span class="string">&#x27;gaussian&#x27;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">blur_img = imfilter(img,h,<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fxx = imfilter(blur_img,[<span class="number">1</span>;<span class="number">-2</span>;<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fyy = imfilter(blur_img,[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>],<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fxy = imfilter(blur_img,[<span class="number">1</span>;<span class="number">0</span>;<span class="number">-1</span>]*[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]/<span class="number">4</span>,<span class="string">&#x27;replicate&#x27;</span>);</span><br><span class="line">fyx = fxy;</span><br><span class="line">H = cell(<span class="built_in">size</span>(img));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">numel</span>(img)</span><br><span class="line">   H&#123;<span class="built_in">i</span>&#125; = [fxx(<span class="built_in">i</span>),fxy(<span class="built_in">i</span>);fyx(<span class="built_in">i</span>),fyy(<span class="built_in">i</span>)];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>图像中检测直线的方法</title>
    <url>/2022/03/15/tu-xiang-zhong-jian-ce-zhi-xian-de-fang-fa/</url>
    <content><![CDATA[<p>就目前所掌握的知识来说，常用的方法有以下 3 种：</p>
<ol type="1">
<li>最小二乘法</li>
<li>$ RANSAC $ （随机采样一致性）</li>
<li>$ Hough $ 线变换</li>
</ol>
<blockquote>
<p>最小二乘法：对<strong>离群点</strong>较为敏感</p>
</blockquote>
<blockquote>
<p>$ RANSAC $
：对检测<strong>多条交叉直线</strong>较为困难，但对离群点较为鲁棒</p>
</blockquote>
<blockquote>
<p>$ Hough $
线变换：<strong>遮蔽点太多</strong>时效果较差，但能检测多条直线</p>
</blockquote>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>特征检测</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的空间变换</title>
    <url>/2022/03/07/tu-xiang-de-kong-jian-bian-huan/</url>
    <content><![CDATA[<h4 id="一引言">一、引言</h4>
<blockquote>
<p>图像的空间变换是将输入图像的像素位置映射到输出图像新的位置处</p>
</blockquote>
<p>图像的空间变换一般可以分为<strong>两类</strong>，一类是可以使用数学函数表达式描述的简单变换，例如<strong>仿射变换</strong>和<strong>透视变换</strong>，另一类则是依赖于实际图像而不易于用函数形式描述的复杂变换，例如对<strong>存在几何畸变的摄像机所拍摄的图像</strong>进行校正，就需要实际拍摄的栅格图像，根据栅格的实际扭曲数据建立空间变换关系。</p>
<p>而上述中的<strong>仿射变换</strong>和<strong>透视变换</strong>又统称为<strong>投影变换</strong>，<strong>仿射变换</strong>为平行投影变换，<strong>透视变换</strong>为中心投影变换，<strong>仿射变换</strong>为线性变换，<strong>透视变换</strong>为非线性变换。</p>
<p>而所谓的<strong>线性变换</strong>（如平移、缩放、旋转和剪切变换），就是保持直线的<strong>平行性</strong>和<strong>平直性</strong>的变换，即原先图像中的直线与平行线映射到另一幅图像中后还是直线和平行线，一个矩形映射为一个平行四边形是<strong>仿射变换</strong>，而一个矩形映射为一个梯形则属于<strong>透视变换</strong>。具体可参考下图：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/trans.png" style="zoom:67%;" /></p>
<hr />
<h4 id="二图像的仿射变换">二、图像的仿射变换</h4>
<h5 id="首先讨论最一般的-3d-空间变换">（1）首先讨论最一般的 3D
空间变换</h5>
<p>一个点 $ X(x_1,x_2,x_3) $ 的仿射变换 $ Y(y_1,y_2,y_3) $ 可以定义为：
<span class="math display">\[
\begin{align*}
y_1 = m_{11}x_1 + m_{12}x_2 + m_{13}x_3 + m_{14}\\
\\
y_2 = m_{21}x_1 + m_{22}x_2 + m_{23}x_3 + m_{24}\\
\\
y_3 = m_{31}x_1 + m_{32}x_2 + m_{33}x_3 + m_{34}\\
\label{eq:(2-1)}
\end{align*}
\]</span> 仿射变换写成矩阵形式为 $ Y = MX $ ： <span
class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
y_3\\
1
\end{pmatrix} =
\begin{pmatrix}
m_{11} &amp; m_{12} &amp; m_{13} &amp; m_{14}\\
m_{21} &amp; m_{22} &amp; m_{23} &amp; m_{24}\\
m_{31} &amp; m_{32} &amp; m_{33} &amp; m_{34}\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
x_3\\
1
\end{pmatrix}
\]</span></p>
<h5 id="分解为子变换平移变换-y-qx">（2）分解为子变换——平移变换 $ Y = QX
$</h5>
<p><span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
y_3\\
1
\end{pmatrix} =
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; q_{1}\\
0 &amp; 1 &amp; 0 &amp; q_{2}\\
0 &amp; 0 &amp; 1 &amp; q_{3}\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
x_3\\
1
\end{pmatrix}
\]</span></p>
<p>此变换只贡献平移量 $ q_{1},q_{2},q_{3} $ ，注意，矩阵写成 $ 4 $
的形式是为了将平移变换统一纳入矩阵运算之中。</p>
<h5 id="分解为子变换旋转变换-y-rx">（3）分解为子变换——旋转变换 $ Y = RX
$</h5>
<p>在 3D 空间中，三个正交平面中的旋转通常表示为沿着相应坐标轴 $ x,y,z $
的旋转，分别表示为：</p>
<p>绕着 $ x $ 轴逆时针旋转： <span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
y_3\\
1
\end{pmatrix} =
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; cos(\alpha) &amp; -sin(\alpha) &amp; 0\\
0 &amp; sin(\alpha) &amp; cos(\alpha) &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
x_3\\
1
\end{pmatrix}
\]</span> 绕着 $ y $ 轴逆时针旋转： <span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
y_3\\
1
\end{pmatrix} =
\begin{pmatrix}
cos(\beta) &amp; 0 &amp; sin(\beta) &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
-sin(\beta) &amp; 0 &amp; cos(\beta) &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
x_3\\
1
\end{pmatrix}
\]</span> 绕着 $ z $ 轴逆时针旋转： <span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
y_3\\
1
\end{pmatrix} =
\begin{pmatrix}
cos(\gamma) &amp; -sin(\gamma) &amp; 0 &amp; 0\\
sin(\gamma) &amp; cos(\gamma) &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
x_3\\
1
\end{pmatrix}
\]</span></p>
<h5 id="分解为子变换缩放变换-y-s_1x">（4）分解为子变换——缩放变换 $ Y =
S_{1}X $</h5>
<p><span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
y_3\\
1
\end{pmatrix} =
\begin{pmatrix}
m_{x} &amp; 0 &amp; 0 &amp; 0\\
0 &amp; m_{y} &amp; 0 &amp; 0\\
0 &amp; 0 &amp; m_{z} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
x_3\\
1
\end{pmatrix}
\]</span></p>
<h5 id="分解为子变换剪切变换-y-s_2x">（5）分解为子变换——剪切变换 $ Y =
S_{2}X $</h5>
<p><span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
y_3\\
1
\end{pmatrix} =
\begin{pmatrix}
1 &amp; s_{1} &amp; s_{2} &amp; 0\\
0 &amp; 1 &amp; s_{3} &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
x_3\\
1
\end{pmatrix}
\]</span></p>
<h5 id="组合变换-y-mx-qrs_1s_2x">（6）组合变换 $ Y = MX = QRS_{1}S_{2}X
$</h5>
<h5 id="本次研究对象是-2d-图像的刚体变换">（7）本次研究对象是 2D
图像的刚体变换</h5>
<blockquote>
<p>刚体变换主要用于同一研究对象的配准，是一种最简单的空间变换。所谓刚体，是指<strong>物体变换前后内部任意两点间的距离保持不变</strong>，也就是说，刚体变换仅仅是仿射变换中<strong>平移变换</strong>和<strong>旋转变换</strong>的组合</p>
<p>从这里我们可以得到一个启示：对于刚体变换，不要一开始就无脑上什么 SIFT
和 SURF
啊什么的，因为它不涉及尺度特性（缩放特性），而是需要仔细分析手上的问题，想清楚后再做决断</p>
</blockquote>
<p>一个二维点 $ X(x_1,x_2) $ 映射为另一个二维点 $ Y(y_{1},y_{2}) $
的旋转矩阵为：（逆时针旋转） <span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
1
\end{pmatrix} =
\begin{pmatrix}
cos(\theta) &amp; -sin(\theta) &amp; 0\\
sin(\theta) &amp; cos(\theta) &amp; 0\\
0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
1
\end{pmatrix}
\]</span> 平移矩阵为： <span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
1
\end{pmatrix} =
\begin{pmatrix}
1 &amp; 0 &amp; q_{1}\\
0 &amp; 1 &amp; q_{2}\\
0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
1
\end{pmatrix}
\]</span> 组合矩阵（组合变换）为： <span class="math display">\[
\begin{pmatrix}
y_1\\
y_2\\
1
\end{pmatrix} =
\begin{pmatrix}
cos(\theta) &amp; -sin(\theta) &amp; q_{1}\\
sin(\theta) &amp; cos(\theta) &amp; q_{2}\\
0 &amp; 0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
1
\end{pmatrix}
\]</span> 可以看出， 2D
图像的空间变换矩阵只依赖于<strong>三个</strong>参数 <span
class="math display">\[
(\;q_{1},\;q_{2},\;\theta\;)
\]</span>
解这<strong>三个</strong>参数，就必须要有<strong>三个</strong>线性无关的方程，因此，就必须知道<strong>两个</strong>点对的坐标
$ (x_{1},x_{2}) $ 和 $ (y_{1},y_{2}) $ 和 $ (x_{3},x_{4}) $ 和 $
(y_{3},y_{4}) $
。（这里允许多一个方程！！！变换矩阵为我们最终所求！！！）</p>
<blockquote>
<p>要记住啊，是<strong>两个</strong>点对，是<strong>两个</strong>点对，是<strong>两个</strong>点对！！！</p>
<p>并且，另说一句，<strong>平移变换 </strong>+ <strong>旋转变换</strong>
+
<strong>缩放变换</strong>也只需要<strong>两个</strong>点对，因为一共只需要求解<strong>四个</strong>未知数</p>
<p>可以参看 Matlab 文档给出的变换类型和点对数需求的说明：</p>
<p><a
href="https://ww2.mathworks.cn/help/images/ref/fitgeotrans.html#bvonaug">Matlab
文档给出的变换类型和点对数需求的说明</a></p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/transtype.png" /></p>
<hr />
<h4 id="三图像的透视变换">三、图像的透视变换</h4>
<p>透视变换常用于图像的<strong>几何校正</strong>，是一种<strong>分式线性变换（非线性变换）</strong>，该过程可以简单地描述为：将一个二维坐标系转换为一个三维坐标系，然后将该三维坐标系投影到新的二维坐标系，体现的是<strong>视角</strong>的变化。</p>
<blockquote>
<p>现阶段学习还用不着，因此此部分以后再写</p>
</blockquote>
<p>虽然但是，<strong>透视变换</strong>真的很有用！先上效果图，有一个直观上的感受：（一张普通公路图变为鸟瞰图）</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/perspective1.jpeg" style="zoom: 25%;" /></p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/perspective2.jpeg" style="zoom: 25%;" /></p>
<hr />
<h4 id="四图像变换后的插值">四、图像变换后的插值</h4>
<p>图像在经过变换后，由于像素点的<strong>坐标取整</strong>会出现归并现象，即有可能有多个原图像的像素点同时变换到新图像中同一个像素点的位置上。这样就出现了在变换后的新图像上有若干原图像像素点<strong>叠加</strong>，或者<strong>排列位置破坏了原有的相邻关系</strong>。另外，有些点无对应的原像素点来填充，由此会在变换后的图像中出现<strong>“空穴”</strong>，这些<strong>“空穴”</strong>的像素值需要进一步确定，以保持图像外观上的“连续性”。此时便需要用到图像插值的方法。</p>
<blockquote>
<p>现阶段学习还用不着，因此此部分以后再写</p>
</blockquote>
<hr />
<h4 id="五参考文章">五、参考文章</h4>
<p>推荐这两篇博文：</p>
<p>（1）<a
href="https://blog.csdn.net/qq_36523492/article/details/109723705">liangbaqiang的博客</a></p>
<p>（2）<a
href="https://cloud.tencent.com/developer/article/1638969">周旋的博客</a></p>
<p>还有一本小书：</p>
<p>上官晋太：《图像配准中的若干问题研究》</p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>图像配准</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>图像配准</tag>
      </tags>
  </entry>
  <entry>
    <title>基于相位相关的图像配准技术</title>
    <url>/2022/03/11/ji-yu-xiang-wei-xiang-guan-de-tu-xiang-pei-zhun-ji-zhu/</url>
    <content><![CDATA[<h4 id="一相位相关法的基本原理">一、相位相关法的基本原理</h4>
<blockquote>
<p>依据：傅里叶变换的<strong>平移性质</strong>（注：此文仅针对<strong>平移失配</strong>的问题展开讨论）</p>
</blockquote>
<p>现给定两幅 $ 2D $ 图像 $ I_{1}(x,y) $ 和 $ I_{2}(x,y) $
，它们之间的唯一区别是一个平移量 $ (d_{x},d_{y}) $ ，即： <span
class="math display">\[
I_{2}(x, \; y) = I_{1}(x-d_{x}, \; y-d_{y})
\]</span> 则它们的傅里叶变换 $ F_{1} $ 和 $ F_{2} $ 满足关系： <span
class="math display">\[
F_{2}(\omega_{x},\omega_{y}) = e^{-j(\omega_{x}d_{x} +
\omega_{y}d_{y})}F_{1}(\omega_{x},\omega_{y})
\]</span>
对二者取模，发现它们的<strong>幅值相等</strong>，仅差了一个<strong>相位</strong>：
<span class="math display">\[
|F_{2}(\omega_{x},\omega_{y})| = |e^{-j(\omega_{x}d_{x} +
\omega_{y}d_{y})}F_{1}(\omega_{x},\omega_{y})|
= |e^{-j(\omega_{x}d_{x} + \omega_{y}d_{y})}| \; \times \;
|F_{1}(\omega_{x},\omega_{y})|
= |F_{1}(\omega_{x},\omega_{y})|
\]</span> 于是，定义两幅图像的<strong>互功率谱</strong>： <span
class="math display">\[
\frac{F_{1}(\omega_{x},\omega_{y})F_{2}^*(\omega_{x},\omega_{y})}
{|F_{1}(\omega_{x},\omega_{y})F_{2}^*(\omega_{x},\omega_{y})|}
= e^{j(\omega_{x}d_{x} + \omega_{y}d_{y})}
\]</span>
对其进行傅里叶逆变换，可以得到一个冲激函数：（它在其它各处几乎为零，<strong>只在平移的位置上不为零</strong>）
<span class="math display">\[
{\scr{F}^{-1}}(e^{j(\omega_{x}d_{x} + \omega_{y}d_{y})})
= \delta(x+d_{x}, \; y+d_{y})
\]</span> 通过寻找冲激函数的位置，便能确定平移量 $ (d_{x},d_{y}) $
的大小</p>
<blockquote>
<p>因此，总结起来，相位相关技术就是<strong>确定互功率谱相位的傅里叶逆变换的峰值的位置</strong></p>
<p>相位差对于所有频率的作用是相同的，因此即使图像中混有窄带噪声，也不会使峰值的位置发生变化</p>
<p>另外，待配准的图像还可以有不同的亮度，因为亮度的变化通常是缓慢的，集中在低频部分，且不影响峰值的位置</p>
</blockquote>
<hr />
<h4 id="二相位相关法的代码实现">二、相位相关法的代码实现</h4>
<h5 id="实现代码">（1）实现代码：</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;clear;clc;</span><br><span class="line">I = imread( <span class="string">&#x27;head.tif&#x27;</span> );</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(I,<span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">    I = rgb2gray(I);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">transI = imtranslate(I,[<span class="number">100</span>,<span class="number">80</span>]);</span><br><span class="line"><span class="built_in">figure</span>; imshowpair(I,transI,<span class="string">&#x27;montage&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>; imshowpair(I,transI);</span><br><span class="line">[row,col] = <span class="built_in">size</span>(I);</span><br><span class="line">FFT1 = fft2(I);</span><br><span class="line">FFT2 = <span class="built_in">conj</span>(fft2(transI));</span><br><span class="line">FFTR = FFT1 .* FFT2;</span><br><span class="line">FFTRN = (FFTR ./ <span class="built_in">abs</span>(FFTR));</span><br><span class="line">result = ifft2(FFTRN);</span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>] = <span class="built_in">find</span>(result == <span class="built_in">max</span>(result(:)));</span><br><span class="line">res = [col+<span class="number">1</span>-<span class="built_in">j</span>,row+<span class="number">1</span>-<span class="built_in">i</span>];    <span class="comment">% 修正坐标</span></span><br><span class="line">corrI = imtranslate(transI,-res);</span><br><span class="line"><span class="built_in">figure</span>; imshowpair(I,corrI);</span><br><span class="line"><span class="built_in">figure</span>; colormap(<span class="string">&#x27;jet&#x27;</span>); mesh(result); axis off;</span><br></pre></td></tr></table></figure>
<h5 id="实现效果">（2）实现效果：</h5>
<p>这是手动添加 $ (100,80) $ 平移量的效果：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/phaseCorrelation/phase1.png" style="zoom:67%;" /></p>
<p>若直接“配准”，会产生如下效果：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/phaseCorrelation/phase2.png" style="zoom:67%;" /></p>
<p>使用相位相关法<strong>修正平移量</strong>后，再进行配准：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/phaseCorrelation/phase3.png" style="zoom:67%;" /></p>
<p>最后观察一下冲激函数：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageTransformation/phaseCorrelation/phase4.png" style="zoom:67%;" /></p>
<hr />
<h4 id="三参考文章">三、参考文章</h4>
<p><a
href="https://blog.csdn.net/EbowTang/article/details/51287309">EbowTang的博客</a></p>
<p>上官晋太的《图像配准中的若干问题研究》</p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>图像配准</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>图像配准</tag>
      </tags>
  </entry>
  <entry>
    <title>图像融合概述</title>
    <url>/2022/03/25/tu-xiang-rong-he-gai-shu/</url>
    <content><![CDATA[<h4 id="一图像融合的层次">一、图像融合的层次</h4>
<blockquote>
<p>图像融合的三个层次（三种分类）是：像素级融合、特征级融合、决策级融合</p>
</blockquote>
<h5
id="像素级融合研究最多应用最广的融合层次">1、像素级融合（研究最多，应用最广的融合层次）</h5>
<p>像素级融合是<strong>最低层次</strong>的融合，它的处理对象是单个像素。</p>
<p>常见的作法是对相应位置处的像素取最大值、最小值或平均值进行融合。</p>
<p>它对图像配准的精度要求很高（像素级精度），是三个融合层次中难度最大的层次。</p>
<p>可借助于下图帮助理解：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFusion/%E5%83%8F%E7%B4%A0%E8%9E%8D%E5%90%88.png" style="zoom: 50%;" /></p>
<p>其大致流程为：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFusion/%E5%83%8F%E7%B4%A0%E7%BA%A7%E8%9E%8D%E5%90%88.png" style="zoom:67%;" /></p>
<h5 id="特征级融合">2、特征级融合</h5>
<p>特征级融合的层次<strong>介于像素级和决策级之间</strong>，其主要针对目标是图像的特征（如几何特征、谱特征、统计特征等）。</p>
<p>特征相对于原图像信息而言往往是稀疏的，能有效地提高图像融合的计算速度。</p>
<p>其大致流程为：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFusion/%E7%89%B9%E5%BE%81%E7%BA%A7%E8%9E%8D%E5%90%88.png" style="zoom:67%;" /></p>
<h5 id="决策级融合">3、决策级融合</h5>
<p>决策级融合的层次是<strong>最高的</strong>，它针对决策问题的具体目标，不太关心微小细节。</p>
<p>其思想是模拟人分析、推理和判决图像的过程，融合的是决策本身而不是像素或者特征（有点类似于<strong>投票表决</strong>）。</p>
<p>它的优点是具有很好的灵活性，不易受噪声的干扰；缺点是预处理的代价高昂。</p>
<p>其大致流程为：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFusion/%E5%86%B3%E7%AD%96%E7%BA%A7%E8%9E%8D%E5%90%88.png" style="zoom: 80%;" /></p>
<hr />
<h4 id="二像素级融合的方法">二、像素级融合的方法</h4>
<blockquote>
<p>针对像素级的融合问题，现有的解决方法大致分为三类：</p>
<p>空间域融合方法、变换域融合方法以及深度学习方法</p>
</blockquote>
<p>分类树如下图所示：</p>
<p><img
src="https://raw.githubusercontent.com/chubbylhao/myPics/106e2c2ad0e0b3d193ebdf928d77409a8dc00b0d/imageFusion/%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95.svg" /></p>
<hr />
<h4 id="三空域简单融合实例">三、空域简单融合实例</h4>
<p><img
src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFusion/%E7%AE%80%E5%8D%95%E8%9E%8D%E5%90%88%E5%AE%9E%E4%BE%8B.png" /></p>
<hr />
<h4 id="四拉普拉斯金字塔融合实例">四、拉普拉斯金字塔融合实例</h4>
<p><img
src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageFusion/%E9%87%91%E5%AD%97%E5%A1%94%E8%9E%8D%E5%90%88%E5%AE%9E%E4%BE%8B.png" /></p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>图像融合</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>图像融合</tag>
      </tags>
  </entry>
  <entry>
    <title>图像聚类分割中经典的k-means和fuzzy c-means算法</title>
    <url>/2022/04/01/tu-xiang-ju-lei-fen-ge-zhong-jing-dian-de-k-means-he-fuzzy-c-means-suan-fa/</url>
    <content><![CDATA[<h4 id="一-k-means-算法和-fuzzy-c-means-算法概述">一、 $ k-means $
算法和 $ fuzzy-c-means $ 算法概述</h4>
<p>$ k-means $ 算法和 $ fuzzy-c-means $
算法都是基于<strong>划分</strong>的聚类方法，该方法的核心思想是：</p>
<p>将待分割目标分类为不同的簇，使得同一簇内的个体<strong>相似度</strong>最高、不同簇之间的个体<strong>差异度</strong>最高</p>
<p>$ fuzzy-c-means $ 算法由 $ k-means $
算法改进而来（二者可用<strong>统一理论</strong>描述），改变了<strong>“非此即彼”</strong>的分类观念</p>
<p>$ k-means $ 为<strong>硬聚类</strong>算法，而$ fuzzy-c-means $
为<strong>软聚类</strong>算法</p>
<hr />
<h4 id="二-k-means-算法又名-c-means-算法">二、 $ k-means $ 算法（又名 $
c-means $ 算法）</h4>
<p>首先将图像整型为 $ n * s $ 的形式，其中 $ n $ 是像素点的总个数， $ s
$ 是图像的通道数，对于灰度图像需要整型成 $ n * 1 $
的形式，而对于真彩色图像（如RGB图像）则需要整型成 $ n * 3 $ 的形式</p>
<p>在上述 $ n * s $ 的特征向量矩阵中，使用随机数生成算法选取 $ k $
个行向量 $ k * s $ 作为初始的聚类中心矩阵</p>
<p>计算图像上的每一个像素点所代表的特征向量与聚类中心的欧式距离，比较并将其划分给距离最小的那个聚类中心，<strong>一个像素点只允许被划分给一个聚类中心</strong></p>
<p>划分完一轮后，取每一个聚类中所有像素点所代表的特征向量的<strong>平均值</strong>作为新的聚类中心</p>
<p>计算相邻两次聚类中心之间欧氏距离的和（称为残差）并和阈值相比较，若小于阈值，则迭代结束，反之则重新迭代</p>
<p>其流程展示如下：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageSegmentation/Clustering/k_means.png" style="zoom: 67%;" /></p>
<hr />
<h4 id="三-fuzzy-c-means-算法">三、 $ fuzzy-c-means $ 算法</h4>
<p>搞清楚<strong>隶属度矩阵</strong>的含义，便不难理解模糊聚类算法</p>
<p>其流程展示如下：</p>
<p><img src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageSegmentation/Clustering/fuzzy_c_means.png" style="zoom: 50%;" /></p>
<hr />
<h4 id="四观察二者的分割结果">四、观察二者的分割结果</h4>
<p>首先观察 $ k-means $ 算法的分割结果：</p>
<p><img
src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageSegmentation/Clustering/kmeans.png" /></p>
<p>再观察 $ fuzzy-c-means $ 算法的分割结果：</p>
<p><img
src="https://raw.githubusercontent.com/chubbylhao/myPics/main/imageSegmentation/Clustering/cmeans.png" /></p>
<p>可以很明显地看出，模糊聚类对于归并<strong>“突兀的异类像素”</strong>有着更好的结果，究其本质是模糊理论的<strong>容错率、纠错率</strong>更高</p>
]]></content>
      <categories>
        <category>图像处理</category>
        <category>图像分割</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>解读Python包结构时的一些记录</title>
    <url>/2022/04/10/jie-du-python-bao-jie-gou-shi-de-yi-xie-ji-lu/</url>
    <content><![CDATA[<h4 id="了解-python-包结构的一些记录">了解 <code>python</code>
包结构的一些记录</h4>
<p><code>_...</code> 通常用作“内部”名称，以 <code>_</code>
开头的模块（包、 <code>.py</code>
文件）不应该被（用户、外部使用者而非内部开发人员）直接导入（
<code>import</code> ）使用</p>
<p><code>python</code> 的 <code>.py</code>
文件、模块、包和库之间的关系，注意使用 <code>__init__.py</code>
文件声明一个 <code>python</code> 包</p>
<p>不推荐使用 <code>from ... import *</code>
语句，这样容易引起同名函数的混乱</p>
<p><code>__name__</code> 是 <code>python</code>
内置的系统变量，用于标识当前所在模块的模块名，其值为
<code>__main__</code> ，但若引入了其它模块，则
<code>其它模块名.__name__</code> 的值是该模块的名称，当
<code>import 其它模块</code> 时，其它模块中的
<code>if __name__ == "__main__"</code>
中的内容不会被执行，具体内容链接：<a
href="http://c.biancheng.net/view/4643.html">http://c.biancheng.net/view/4643.html</a></p>
<p>引入<strong>含有空格</strong>或<strong>以数字开头</strong>（最好以字母和下划线开头）的模块名，应该使用
<code>__import__("模块名")</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&quot;含有空格或以数字开头的模块名&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当向文件导入某个模块时，导入的是该模块中那些名称不以下划线（单下划线
<code>“_”</code> 或者双下划线 <code>"__"</code>
）开头的变量、函数和类。因此，如果不想模块文件中的某个成员被引入到其它文件中使用，可以在其名称前添加下划线</p>
<p>除此之外，还可以借助模块提供的 <code>__all__</code>
变量，该变量的值是一个列表，存储的是当前模块中的一些成员（变量、函数和类）的名称。通过在模块文件中设置
<code>__all__</code> 变量，当其它文件以
<code>from 模块命 import *</code> 的形式导入该模块时，该文件中只能使用
<code>__all__</code> 列表中指定的成员，具体内容链接：<a
href="http://c.biancheng.net/view/2401.html">http://c.biancheng.net/view/2401.html</a></p>
<p><code>python</code> 中下划线的 <code>5</code> 种含义：<a
href="https://zhuanlan.zhihu.com/p/36173202">https://zhuanlan.zhihu.com/p/36173202</a></p>
<p><code>cython</code> （文件后缀 <code>.pyx</code> ）是结合了
<code>python</code> 和 <code>c</code>
的语法的一种语言，被编译后其源代码将转译成 <code>c</code> 或
<code>c++</code> 语法，并自动包装上函数调用界面生成 <code>.pyd</code>
（或 <code>.so</code> ，因操作系统而异）后缀的二进制文档，即可当成普通的
<code>python</code> 库来调用，此内容在 <code>wikipedia</code>
上有详细介绍：<a
href="https://zh.wikipedia.org/wiki/Cython">https://zh.wikipedia.org/wiki/Cython</a></p>
<hr />
<h4 id="常常回来翻阅一下以加深理解">常常回来翻阅一下，以加深理解</h4>
<p><a
href="http://c.biancheng.net/python/module_package/">C语言中文网/Python教程</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的傅里叶变换</title>
    <url>/2022/09/10/tu-xiang-de-fu-li-xie-bian-huan/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>图像处理</category>
        <category>图像变换</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>图像变换</tag>
      </tags>
  </entry>
</search>
